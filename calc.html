<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Mid-Drive Planner v10 ‚Äî Gearing ‚Ä¢ Grades ‚Ä¢ Range ‚Ä¢ Uncertainty ‚Ä¢ Gear Visualizer</title>
<style>
  :root{
    --bg:#070b10;--panel:#0f1622;--ink:#e8eef6;--muted:#a9b7c6;
    --accent:#4da3ff;--accent2:#7dffb0;--warn:#ffb84d;--danger:#ff6b6b;--grid:#233040;
    --glow1:#3ea1ff;--glow2:#80ffcf
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  /* Neon background (static, no panning/animation) */
  body::before{
    content:"";position:fixed;inset:0;pointer-events:none;z-index:-2;opacity:.35;
    background:
      radial-gradient(80vmax 80vmax at 20% 10%, #143055 0%, transparent 55%),
      radial-gradient(80vmax 80vmax at 80% 80%, #0d3a2c 0%, transparent 55%),
      repeating-linear-gradient(0deg, #0b1320 0 2px, #0b1320 2px 20px, #0c1624 20px 40px);
    mix-blend-mode:screen;
  }
  /* Remove scanline overlay entirely */
  body::after{display:none!important}

  header{
    padding:14px 16px;border-bottom:1px solid #182232;
    background:linear-gradient(180deg,#0c121a,#0a0f15);
    position:sticky;top:0;z-index:5
  }
  h1{font-size:18px;margin:0 0 4px 0;
    background:linear-gradient(90deg,#cfe2ff,#b9ffdb);
    -webkit-background-clip:text;background-clip:text;color:transparent
  }
  .sub{color:var(--muted);font-size:12px}
  main{padding:12px;max-width:1200px;margin:0 auto}
  .grid{display:grid;gap:12px}
  @media(min-width:1020px){.grid{grid-template-columns:440px 1fr}}
  .card{
    background:rgba(18,24,33,.88);
    border:1px solid #182232;border-radius:14px;padding:12px;
    box-shadow:0 10px 30px #00000066, inset 0 1px 0 #ffffff08;
    transition:transform .25s ease, box-shadow .25s ease, border-color .25s ease
  }
  .card:hover{transform:translateY(-2px); box-shadow:0 16px 46px #00000080, 0 0 0 1px #3aa1ff20}
  .inputs{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .inputs .full{grid-column:1/-1}
  label{
    font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px;margin-bottom:4px
  }
  input,select,button{
    width:100%;box-sizing:border-box;border-radius:10px;border:1px solid #3a4b60;background:#1a2634;
    color:#ffffff;padding:10px 12px;font-size:14px;outline:none;font-weight:500
  }
  input:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 3px #4da3ff22;background:#203040}
  input:hover,select:hover{border-color:#4a5b70;background:#1f2e3f}
  input[disabled],select[disabled]{background:#0f1a25;color:#8a9aa6;border-color:#2a3540;opacity:0.7}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{
    position:relative;background:linear-gradient(180deg,#49a0ff,#2a6fbf);color:#001b33;border:none;font-weight:700;cursor:pointer
  }
  .btn.secondary{background:linear-gradient(180deg,#14202f,#0f1a29);color:var(--ink);border:1px solid #223044}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  /* Kill glossy sideways sheen */
  .btn::after{content:none!important}

  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#162131;border:1px solid #223044;color:var(--ink);font-size:12px;cursor:pointer}
  .section-title{font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:.12em;margin:4px 0 8px;display:flex;align-items:center;gap:6px}
  
  /* Enhanced section styling */
  .input-section{
    background:rgba(29, 44, 63, 0.6);
    border:1px solid #1a2634;
    border-radius:12px;
    padding:16px;
    margin-bottom:16px;
    position:relative;
    transition:all .25s ease;
  }
  .input-section:hover{
    background:rgba(37, 78, 134, 0.8);
    border-color:#2a3b55;
  }
  .input-section .section-title{
    margin:-4px 0 12px 0;
    font-size:14px;
    font-weight:600;
    color:var(--accent2);
  }
  .section-icon{
    width:18px;
    height:18px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size:14px;
    color:var(--accent);
    background:rgba(77,163,255,.15);
    border-radius:6px;
    flex-shrink:0;
  }
  
  canvas{width:100%;height:260px;border-radius:12px;background:#0b1118;border:1px solid #182232;box-shadow:inset 0 0 0 1px #ffffff08}
  table{width:100%;border-collapse:collapse;font-size:12px}
  th,td{padding:6px 8px;border-bottom:1px solid #1a2634;text-align:right}
  th{color:var(--muted);font-weight:600}
  td:first-child,th:first-child{text-align:left}
  tbody tr.sel{background:linear-gradient(90deg,#0f1622,#0e1f31)}
  tbody tr.sel td{box-shadow:inset 0 0 0 1px #3ea1ff22}
  tbody tr:hover{background:#101a28}
  .note{color:var(--muted);font-size:12px;line-height:1.45}
  .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#1b2838;color:var(--ink);font-size:11px;border:1px solid #223044;box-shadow:0 0 0 1px #ffffff08}
  .ok{color:#7dffb0}.no{color:#ff6b6b}
  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  #gearVis{display:grid;grid-template-columns:1fr auto 1fr;gap:8px;align-items:center}
  #gearVis .col{background:#0c121a;border:1px solid #182232;border-radius:10px;padding:8px;text-align:center;box-shadow:inset 0 0 0 1px #ffffff08}
  #gearVis .val{font-size:18px;font-weight:700}
  #gearControls{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:8px}
  #gearControls button{width:auto;min-width:44px}
  #gearCanvas{height:260px}
  .narrow{max-width:520px}
  .small{font-size:11px}.muted{color:var(--muted)}
  .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .toolbar .group{display:flex;gap:6px;align-items:center}
  .toolbar .seg{display:inline-flex;border:1px solid #223044;border-radius:8px;overflow:hidden}
  .toolbar .seg button{border:none;background:#14202f;padding:6px 10px;font-size:12px;cursor:pointer;color:#cfe2ff}
  .toolbar .seg button.active{background:#1e2c40;color:#b9ffdb}

  /* Respect reduced motion for canvas animation only */
  @media (prefers-reduced-motion: reduce){
    /* canvas animation controlled in JS; no CSS motion left */
  }

  /* ---------- Tooltip system (desktop + mobile) ---------- */
  .help-icon{
    --size:18px;
    width:var(--size);height:var(--size);
    border-radius:50%;
    border:1px solid #2a3b55;
    background:radial-gradient(circle at 30% 30%, #234064, #0e1723);
    color:#cfe2ff;font-weight:800;font-size:12px;line-height:1;
    display:inline-flex;align-items:center;justify-content:center;
    cursor:help; position:relative; flex:0 0 auto;
  }
  .help-icon:focus-visible{outline:2px solid #4da3ff66;outline-offset:2px}
  .tip-bubble{
    position:absolute;left:50%;bottom:calc(100% + 8px);
    transform:translateX(-50%) translateY(6px) scale(.98);
    background:#0d1623;border:1px solid #243248;border-radius:10px;box-shadow:0 10px 30px #00000066, 0 0 0 1px #ffffff08;
    padding:10px; width:min(260px, 82vw); color:#e8eef6; font-size:12px; line-height:1.45; z-index:50;
    opacity:0; pointer-events:none; transition:opacity .15s ease, transform .15s ease;
  }
  .tip-bubble .tip-title{display:block;font-weight:700;color:#b9ffdb;margin-bottom:4px}
  .tip-bubble::after{
    content:"";position:absolute;left:50%;top:100%;transform:translateX(-50%) rotate(180deg);
    border-width:8px;border-style:solid;border-color:#0d1623 transparent transparent transparent;
    filter:drop-shadow(0 2px 0 #243248);
  }
  /* Show on hover/focus or when toggled open via JS */
  .help-icon:hover .tip-bubble,
  .help-icon:focus .tip-bubble,
  .help-icon.open .tip-bubble{
    opacity:1; pointer-events:auto; transform:translateX(-50%) translateY(0) scale(1);
  }
  /* Tooltip inside headers with less vertical space: push below if needed */
  .tip-below .tip-bubble{ top:calc(100% + 8px); bottom:auto }
  .tip-below .tip-bubble::after{
    top:auto; bottom:100%; transform:translateX(-50%) rotate(180deg)
  }
</style>
</head>
<body>
<header>
  <div class="toolbar">
    <h1 style="margin-right:auto">Mid-Drive Planner v10</h1>
    <div class="group">
      <span class="small muted">Speed</span>
      <div class="seg" role="tablist" aria-label="Speed units">
        <button type="button" id="u_mph" class="active" aria-selected="true">mph</button>
        <button type="button" id="u_kph" aria-selected="false">km/h</button>
      </div>
    </div>
    <div class="group">
      <span class="small muted">FX</span>
      <div class="seg" role="tablist" aria-label="Visual effects">
        <button type="button" id="fx_on" class="active" aria-selected="true">On</button>
        <button type="button" id="fx_off" aria-selected="false">Off</button>
      </div>
      <button id="fx_play" class="btn secondary" type="button" style="min-width:88px">Pause</button>
    </div>
  </div>
  <div class="sub">No distracting sweeps. Animated sprockets & chain remain. Tap the ‚Äú?‚Äù icons for inline help (works on mobile).</div>
</header>

<main class="grid">
  <!-- LEFT PANEL -->
  <section class="card">
    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üö≤</span>
        Bike
      </div>
      <div class="inputs">
        <div><label for="wheelPreset">Wheel size preset</label>
          <select id="wheelPreset">
            <option value="2100">26‚Ä≥ (‚âà2100 mm)</option>
            <option value="2230">27.5‚Ä≥ (‚âà2230 mm)</option>
            <option value="2310">29‚Ä≥ / 700c (‚âà2310 mm)</option>
            <option value="custom">Use custom circumference</option>
          </select>
        </div>
        <div><label for="circumference">Custom circumference (mm)</label><input id="circumference" type="number" placeholder="e.g. 2100" min="1" step="1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">‚öôÔ∏è</span>
        Drivetrain
      </div>
      <div class="inputs">
        <div><label for="frontTeeth">Front chainring teeth</label><input id="frontTeeth" type="number" value="40" min="22" max="60" step="1"></div>
        <div><label for="rearCogs">Rear cogs (teeth, CSV)</label><input id="rearCogs" class="full" type="text" value="13,14,16,18,21,24,28,34" inputmode="numeric"></div>
        <div><label for="driveEff">Drivetrain efficiency</label><input id="driveEff" type="number" step="0.01" value="0.95" min="0" max="1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üë§</span>
        Rider
      </div>
      <div class="inputs">
        <div><label for="mass">Total mass (kg)</label><input id="mass" type="number" value="160" min="1" step="0.1"></div>
        <div><label for="riderW">Rider watts</label><input id="riderW" type="number" value="0" min="0" step="1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üìà</span>
        Grades
      </div>
      <div class="inputs">
        <div><label for="climbMph"><span id="lbl_climb">Target climb speed (mph)</span></label><input id="climbMph" type="number" value="3" min="0" step="0.1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">‚ö°</span>
        Motor
      </div>
      <div class="inputs">
        <div><label for="crankTorque">Crank torque (Nm)</label><input id="crankTorque" type="number" value="160" min="0" step="0.1"></div>
        <div><label for="maxCadence">Max chainring rpm</label><input id="maxCadence" type="number" value="140" min="0" step="1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üîå</span>
        Power
      </div>
      <div class="inputs">
        <div class="full"><label for="powerMode">Power entry mode</label>
          <select id="powerMode">
            <option value="va">Voltage √ó Current √ó Efficiency (battery-based)</option>
            <option value="mech">Direct mechanical watts (at the shaft)</option>
          </select>
        </div>
        <div><label for="voltage">Battery voltage (V)</label><input id="voltage" type="number" value="52" min="0" step="0.1"></div>
        <div><label for="current">Controller current (A)</label><input id="current" type="number" value="30" min="0" step="0.1"></div>
        <div><label for="motorEff">Motor+controller efficiency</label><input id="motorEff" type="number" step="0.01" value="0.82" min="0" max="1"></div>
        <div><label for="mechW">Mechanical watts (if using direct)</label><input id="mechW" type="number" value="1280" min="0" step="1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üîã</span>
        Battery
      </div>
      <div class="inputs">
        <div><label for="batAh">Battery capacity (Ah)</label><input id="batAh" type="number" value="20" min="0" step="0.1"></div>
        <div><label for="usablePct">Usable % (leave reserve)</label><input id="usablePct" type="number" value="85" min="0" max="100" step="1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üìè</span>
        Range
      </div>
      <div class="inputs">
        <div><label for="rangeMph"><span id="lbl_range">Range cruise speed (mph)</span></label><input id="rangeMph" type="number" value="20" min="0" step="0.1"></div>
        <div><label for="rangeGradePct">Target climb grade for range (%)</label><input id="rangeGradePct" type="number" value="10" min="0" step="0.1"></div>
      </div>
    </div>

    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üíæ</span>
        Presets & Share
      </div>
      <div class="row">
        <button class="pill" data-rear="14,16,18,20,22,24,26">7-spd 14‚Äì26</button>
        <button class="pill" data-rear="13,14,16,18,21,24,28,34">MegaRange 13‚Äì34</button>
        <button class="pill" data-rear="12,14,16,18,21,24,28,32">8-spd 12‚Äì32</button>
        <button class="pill" id="preset_power">52 V √ó 30 A (0.82)</button>
        <button class="pill" id="preset_rpm">Spec: 150 rpm</button>
      </div>
      <div class="row" style="margin-top:6px">
        <input id="presetName" placeholder="Preset name" style="max-width:220px" aria-label="Preset name">
        <button id="savePreset" class="btn secondary" type="button">Save</button>
        <select id="loadPreset" style="max-width:220px"><option value="">Load preset‚Ä¶</option></select>
        <button id="deletePreset" class="btn secondary" type="button">Delete</button>
        <button id="shareBtn" class="btn" type="button">Share</button>
        <span id="shareMsg" class="small muted" role="status" aria-live="polite"></span>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="computeBtn" class="btn" type="button">Compute</button>
        <button id="resetBtn" class="btn secondary" type="button">Reset defaults</button>
        <button id="exportCsv" class="btn secondary" type="button">Export CSV</button>
      </div>
    </div>
  </section>

  <!-- RIGHT PANEL -->
  <section class="card">
    <div class="section-title">Global summary</div>
    <div id="summary" class="note" role="status" aria-live="polite"></div>

    <div class="two-col" style="gap:12px; margin-top:10px">
      <div>
        <div class="section-title">Range estimate</div>
        <div id="rangeBox" class="note" role="status" aria-live="polite"></div>
      </div>
      <div>
        <div class="section-title">Slope per gear (visual)</div>
        <canvas id="chartSlope" style="height:200px" role="img" aria-label="Per-gear slope visualisation"></canvas>
      </div>
    </div>

    <div class="section-title" style="margin-top:12px">Gear visualizer ‚Äî chainring ‚Üí cog ‚Üí wheel</div>
    <div class="narrow">
      <div class="row">
        <label for="visRpm">Visualizer chainring rpm</label>
        <input id="visRpm" type="range" min="0" max="200" value="1" step="1" style="flex:1">
        <input id="visRpmNum" type="number" value="1" min="0" max="300" step="1" style="width:90px">
      </div>
    </div>
    <div id="gearVis">
      <div class="col">
        <div class="note">Chainring</div>
        <div class="val" id="gv_crank_rpm">1.00 rpm</div>
        <div class="note" id="gv_frontT">‚Äî</div>
      </div>
      <div style="text-align:center">
        <div id="gearControls">
          <button id="gearDown" class="btn" title="Shift to a smaller rear sprocket (harder gear)" aria-label="Shift down">‚ñº</button>
          <div class="badge" id="gv_label">Gear 1/‚Äî</div>
          <button id="gearUp" class="btn" title="Shift to a larger rear sprocket (easier gear)" aria-label="Shift up">‚ñ≤</button>
        </div>
        <div class="note" id="gv_ratio">ratio ‚Äî</div>
      </div>
      <div class="col">
        <div class="note">Wheel</div>
        <div class="val" id="gv_wheel_rpm">‚Äî rpm</div>
        <div class="note" id="gv_speed">‚Äî</div>
      </div>
    </div>
    <canvas id="gearCanvas" role="img" aria-label="Animated chainring, cog and wheel with chain motion"></canvas>

    <div class="section-title" style="margin-top:12px">Per-gear results</div>
    <div class="note" style="margin-bottom:6px">
      <span class="badge">Columns</span>
      "Top speed" = actual top speed considering both power and RPM limits in each gear. 
      "Max grade (torque @v)" uses your set climb speed. "Actual" = min(power-limit, torque-limit).
    </div>
    <div style="overflow:auto">
      <table id="resultTable">
        <thead><tr>
          <th>Gear</th><th>Ratio</th><th id="th_top">Top speed (mph)</th>
          <th>Wheel torque (Nm)</th><th>Max grade (torque @v)</th><th>Max grade (actual @v)</th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="section-title" style="margin-top:8px">Gear summary</div>
    <div id="gearSummary" class="note"></div>

    <div class="section-title" style="margin-top:14px">Charts</div>
    <div class="grid" style="grid-template-columns:1fr;gap:10px">
      <canvas id="chartSpeed" role="img" aria-label="Top speed per gear line chart"></canvas>
      <canvas id="chartTorque" role="img" aria-label="Wheel torque per gear line chart"></canvas>
      <canvas id="chartGrade" role="img" aria-label="Maximum climb grade per gear line chart"></canvas>
    </div>
  </section>

  <!-- System Designer -->
  <section class="card">
    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üéØ</span>
        System Designer ‚Äî Requirements ‚Üí Specs
      </div>
      <div class="note" style="margin-bottom:12px">Define your riding requirements and let the system calculate the minimum motor specs, gearing, and battery needed. Check the boxes for requirements you want to enforce.</div>
      
      <!-- Requirements Input -->
      <div class="inputs">
        <div class="full" style="background: rgba(77,163,255,0.1); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
          <div style="font-weight: 600; color: var(--accent); margin-bottom: 8px;">Riding Requirements</div>
          <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center;">
            <input type="checkbox" id="req_weight" style="width: auto;">
            <label for="req_weight" style="margin: 0;">Total weight (kg)</label>
            <input id="sys_weight" type="number" value="160" min="50" max="300" step="1" style="width: 80px;">
            
            <input type="checkbox" id="req_topSpeed" style="width: auto;">
            <label for="req_topSpeed" style="margin: 0;"><span id="lbl_sys_topSpeed">Target top speed (mph)</span></label>
            <input id="sys_topSpeed" type="number" value="30" min="5" max="50" step="0.1" style="width: 80px;">
            
            <input type="checkbox" id="req_climbSpeed" style="width: auto;">
            <label for="req_climbSpeed" style="margin: 0;"><span id="lbl_sys_climbSpeed">Climb speed (mph)</span></label>
            <input id="sys_climbSpeed" type="number" value="6" min="1" max="15" step="0.1" style="width: 80px;">
            
            <input type="checkbox" id="req_climbGrade" style="width: auto;">
            <label for="req_climbGrade" style="margin: 0;">Target climb grade (%)</label>
            <input id="sys_climbGrade" type="number" value="15" min="5" max="40" step="1" style="width: 80px;">
            
            <input type="checkbox" id="req_range" style="width: auto;">
            <label for="req_range" style="margin: 0;"><span id="lbl_sys_range">Range (miles)</span></label>
            <input id="sys_range" type="number" value="50" min="10" max="200" step="1" style="width: 80px;">
            
            <input type="checkbox" id="req_rangeSpeed" style="width: auto;">
            <label for="req_rangeSpeed" style="margin: 0;"><span id="lbl_sys_rangeSpeed">Range cruise speed (mph)</span></label>
            <input id="sys_rangeSpeed" type="number" value="20" min="5" max="30" step="0.1" style="width: 80px;">
            
            <input type="checkbox" id="req_rangeGrade" style="width: auto;">
            <label for="req_rangeGrade" style="margin: 0;">Range grade (%)</label>
            <input id="sys_rangeGrade" type="number" value="5" min="0" max="20" step="1" style="width: 80px;">
          </div>
        </div>
        
        <div class="full" style="background: rgba(125,255,176,0.1); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
          <div style="font-weight: 600; color: var(--accent2); margin-bottom: 8px;">Constraints & Preferences</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <div><label for="sys_wheelSize">Wheel size</label>
              <select id="sys_wheelSize">
                <option value="2100">26‚Ä≥ (‚âà2100 mm)</option>
                <option value="2230">27.5‚Ä≥ (‚âà2230 mm)</option>
                <option value="2310" selected>29‚Ä≥ / 700c (‚âà2310 mm)</option>
              </select>
            </div>
            <div><label for="sys_riderWatts">Rider contribution (W)</label>
              <input id="sys_riderWatts" type="number" value="100" min="0" max="400" step="10">
            </div>
            <div><label for="sys_chainringMin">Min chainring size (T)</label>
              <input id="sys_chainringMin" type="number" value="32" min="28" max="60" step="2">
            </div>
            <div><label for="sys_chainringMax">Max chainring size (T)</label>
              <input id="sys_chainringMax" type="number" value="52" min="32" max="70" step="2">
            </div>
            <div><label for="sys_maxRpm">Max acceptable chainring RPM</label>
              <input id="sys_maxRpm" type="number" value="150" min="100" max="200" step="5">
            </div>
            <div><label for="sys_efficiency">Expected drivetrain efficiency</label>
              <input id="sys_efficiency" type="number" value="0.93" min="0.85" max="0.98" step="0.01">
            </div>
            <div><label for="sys_motorEff">Expected motor efficiency</label>
              <input id="sys_motorEff" type="number" value="0.82" min="0.70" max="0.95" step="0.01">
            </div>
            <div><label for="sys_batteryV">Preferred battery voltage (V)</label>
              <input id="sys_batteryV" type="number" value="52" min="36" max="72" step="1">
            </div>
          </div>
        </div>
        
        <div class="full"><button id="designBtn" class="btn" type="button">Design System</button></div>
      </div>
      <div id="designOut" class="note" style="margin-top:8px" role="status" aria-live="polite"></div>
    </div>
  </section>

  <!-- Enhanced Uncertainty -->
  <section class="card">
    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üé≤</span>
        Robustness Analysis ‚Äî Multi-scenario validation
      </div>
      <div class="note" style="margin-bottom:12px">Test your system design across realistic variations in conditions and component specs. This validates that your chosen configuration will work reliably in real-world scenarios with manufacturing tolerances, environmental changes, and usage variations.</div>
      <div class="inputs">
        <div><label for="N"># scenarios to test</label><input id="N" type="number" value="500" min="50" step="50"></div>
        
        <div class="full" style="background: rgba(255,184,77,0.1); padding: 12px; border-radius: 8px; margin: 8px 0;">
          <div style="font-weight: 600; color: var(--warn); margin-bottom: 8px;">Environmental & Usage Variations (¬±%)</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
            <div><label for="var_mass">Mass variation (¬±%)</label>
              <input id="var_mass" type="number" value="10" min="0" max="30" step="1">
            </div>
            <div><label for="var_aero">Aerodynamic drag (¬±%)</label>
              <input id="var_aero" type="number" value="20" min="0" max="50" step="5">
            </div>
            <div><label for="var_rolling">Rolling resistance (¬±%)</label>
              <input id="var_rolling" type="number" value="15" min="0" max="30" step="5">
            </div>
          </div>
        </div>
        
        <div class="full" style="background: rgba(255,107,107,0.1); padding: 12px; border-radius: 8px; margin: 8px 0;">
          <div style="font-weight: 600; color: var(--danger); margin-bottom: 8px;">Component Tolerances (¬±%)</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
            <div><label for="var_torque">Motor torque (¬±%)</label>
              <input id="var_torque" type="number" value="8" min="0" max="20" step="1">
            </div>
            <div><label for="var_power">Motor power (¬±%)</label>
              <input id="var_power" type="number" value="10" min="0" max="25" step="1">
            </div>
            <div><label for="var_efficiency">Efficiency (¬±%)</label>
              <input id="var_efficiency" type="number" value="5" min="0" max="15" step="1">
            </div>
          </div>
        </div>
        
        <div class="full"><button id="robustnessBtn" class="btn" type="button">Run Robustness Analysis</button></div>
      </div>
      <div id="robustnessOut" class="note" style="margin-top:8px" role="status" aria-live="polite"></div>
    </div>
  </section>

  <!-- Reverse engineer -->
  <section class="card">
    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üîÑ</span>
        Reverse engineer gearing
      </div>
      <div class="inputs">
        <div><label for="targetTopMph"><span id="lbl_targetTop">Target top speed (mph)</span></label><input id="targetTopMph" type="number" value="29" min="0" step="0.1"></div>
        <div><label for="targetGradePct">Target climb grade (%)</label><input id="targetGradePct" type="number" value="15" min="0" step="0.1"></div>
        <div class="full"><label for="fixedWhat">What is fixed?</label>
          <select id="fixedWhat">
            <option value="none">Nothing (suggest both)</option>
            <option value="ring">Chainring is fixed</option>
            <option value="cassette">Cassette extremes are fixed</option>
          </select>
        </div>
        <div><label for="fixedRing">Fixed ring (T)</label><input id="fixedRing" type="number" value="40" min="1" step="1"></div>
        <div><label for="fixedSmall">Fixed cassette small (T)</label><input id="fixedSmall" type="number" value="13" min="1" step="1"></div>
        <div><label for="fixedLarge">Fixed cassette large (T)</label><input id="fixedLarge" type="number" value="34" min="1" step="1"></div>
        <div class="full"><button id="solveBtn" class="btn" type="button">Solve gearing</button></div>
      </div>
      <div id="solveOut" class="note" style="margin-top:8px" role="status" aria-live="polite"></div>
    </div>
  </section>

  <!-- Uncertainty -->
  <section class="card">
    <div class="input-section">
      <div class="section-title">
        <span class="section-icon">üé≤</span>
        Uncertainty sweeps (multi-scenario)
      </div>
      <div class="note" style="margin-bottom:12px">Use this to simulate uncertainty by running many scenarios with ranges for key variables. Set min/max for each, then click Run to get the percentage of scenarios that meet your targets and gearing suggestions for robust design. The coverage shows reliability, and the design recommendations help choose components that work across variations.</div>
      <div class="inputs">
        <div><label for="u_N"># samples</label><input id="u_N" type="number" value="300" min="10" step="1"></div>
        <div><label for="u_mass_min">Mass min (kg)</label><input id="u_mass_min" type="number" value="150" min="1" step="0.1"></div>
        <div><label for="u_mass_max">Mass max (kg)</label><input id="u_mass_max" type="number" value="170" min="1" step="0.1"></div>
        <div><label for="u_rpm_min">Max chainring rpm min</label><input id="u_rpm_min" type="number" value="130" min="0" step="1"></div>
        <div><label for="u_rpm_max">Max chainring rpm max</label><input id="u_rpm_max" type="number" value="150" min="0" step="1"></div>
        <div><label for="u_V_min">Voltage min</label><input id="u_V_min" type="number" value="50" min="0" step="0.1"></div>
        <div><label for="u_V_max">Voltage max</label><input id="u_V_max" type="number" value="58" min="0" step="0.1"></div>
        <div><label for="u_A_min">Current min</label><input id="u_A_min" type="number" value="28" min="0" step="0.1"></div>
        <div><label for="u_A_max">Current max</label><input id="u_A_max" type="number" value="35" min="0" step="0.1"></div>
        <div><label for="u_eff_min">Eff min</label><input id="u_eff_min" type="number" step="0.01" value="0.78" min="0" max="1"></div>
        <div><label for="u_eff_max">Eff max</label><input id="u_eff_max" type="number" step="0.01" value="0.85" min="0" max="1"></div>
        <div><label for="u_T_min">Crank torque min (Nm)</label><input id="u_T_min" type="number" value="140" min="0" step="0.1"></div>
        <div><label for="u_T_max">Crank torque max (Nm)</label><input id="u_T_max" type="number" value="170" min="0" step="0.1"></div>
        <div><label for="u_RW_min">Rider W min</label><input id="u_RW_min" type="number" value="0" min="0" step="1"></div>
        <div><label for="u_RW_max">Rider W max</label><input id="u_RW_max" type="number" value="150" min="0" step="1"></div>
        <div class="full"><button id="uncBtn" class="btn" type="button">Run uncertainty</button></div>
      </div>
      <div id="uncOut" class="note" style="margin-top:8px" role="status" aria-live="polite"></div>
    </div>
  </section>
</main>

<script>
/* ====== Core constants + existing compute/render engine (kept) ====== */
(function(){
  const g = 9.80665;
  const MPH_PER_MPS = 2.23693629;
  const KPH_PER_MPS = 3.6;
  const MPS_PER_MPH = 0.44704;
  const stdSmall = [11,12,13,14];
  const stdLarge = [26,28,30,32,34,36,40,42,46,50];

  const $ = s=>document.querySelector(s);
  const $$ = s=>Array.from(document.querySelectorAll(s));

  let gearIndex = 0;
  let firstCompute = true;
  let speedUnit = 'mph'; // 'mph' | 'kph'

  // FX state (canvas animation only)
  const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  let fxEnabled = !prefersReduce;
  let animRunning = !prefersReduce;

  /* ---------- helpers ---------- */
  function parseRear(csv){
    const set = new Set();
    csv.split(',').forEach(s=>{
      const n = parseInt(s.trim(),10);
      if(Number.isFinite(n) && n > 0) set.add(n);
    });
    return Array.from(set).sort((a,b)=>a-b);
  }
  function getCirc(){
    const p = $('#wheelPreset').value;
    const c = parseFloat($('#circumference').value);
    if(p==='custom') return (c>0?c:2100)/1000;
    const mm = parseFloat(p);
    return (c>0 ? c : (mm>0?mm:2100))/1000;
  }
  function binSearchTopSpeedFlat(P, m, Crr, rho, CdA){
    let lo=0, hi=35;
    for(let i=0;i<64;i++){
      const v=(lo+hi)/2;
      const f = 0.5*rho*CdA*v*v*v + m*g*Crr*v - P;
      if(f>0) hi=v; else lo=v;
    }
    return (lo+hi)/2;
  }
  function fmt(n, d=2){ return Number.isFinite(n)? n.toFixed(d) : '‚Äî'; }
  function mphToDisplay(mph){ return speedUnit==='mph' ? mph : mph*1.609344; }
  function mpsToDisplay(mps){ return speedUnit==='mph' ? (mps*MPH_PER_MPS) : (mps*KPH_PER_MPS); }
  function unitLabel(){ return speedUnit==='mph' ? 'mph' : 'km/h'; }
  function setSpeedLabels(){
    $('#lbl_climb').textContent = `Target climb speed (${unitLabel()})`;
    $('#lbl_range').textContent = `Range cruise speed (${unitLabel()})`;
    $('#lbl_targetTop').textContent = `Target top speed (${unitLabel()})`;
    $('#th_top').textContent = `Top speed (${unitLabel()})`;
    setSystemLabels();
  }
  function getSpeedInputMph(id){
    const val = parseFloat($('#'+id).value) || 0;
    return speedUnit==='mph' ? val : (val/1.609344);
  }
  function setSpeedInputDisplayFromMph(id, mph){
    const v = speedUnit==='mph' ? mph : mph*1.609344;
    $('#'+id).value = +v.toFixed(2);
  }
  function clampGear(n, rears){ return Math.max(0, Math.min(n, rears.length-1)); }
  function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }

  /* ---------- charts & slope ---------- */
  function drawChart(canvas, labels, series, options){
    const dpr=Math.max(1,window.devicePixelRatio||1), w=canvas.clientWidth, h=canvas.clientHeight;
    canvas.width=Math.round(w*dpr); canvas.height=Math.round(h*dpr);
    const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,w,h);
    const pad={l:44,r:10,t:16,b:30}, plotW=w-pad.l-pad.r, plotH=h-pad.t-pad.b;
    ctx.fillStyle='#a9b7c6'; ctx.font='12px system-ui,sans-serif'; ctx.textAlign='left'; ctx.textBaseline='top';
    if(options&&options.title) ctx.fillText(options.title,pad.l,4);
    let ymin=Infinity,ymax=-Infinity;
    series.forEach(s=>s.data.forEach(v=>{ if(v==null)return; ymin=Math.min(ymin,v); ymax=Math.max(ymax,v);})); 
    if(!isFinite(ymin)||!isFinite(ymax)){ymin=0;ymax=1;} if(ymin===ymax){ymin=0;ymax=ymax||1;}
    const padY=(ymax-ymin)*0.08||1; ymin-=padY; ymax+=padY;
    const xTo=(i)=> pad.l + (plotW*(labels.length<=1?0:i/(labels.length-1)));
    const yTo=(v)=> pad.t + plotH*(1 - (v - ymin)/(ymax - ymin));
    const grid='#233040'; const ax='#7d92a9';
    const pal=['#4da3ff','#7dffb0','#ffb84d','#ff6b6b','#c18bff'];
    ctx.strokeStyle=grid; ctx.lineWidth=1; ctx.beginPath();
    for(let gy=0;gy<=5;gy++){ const y=pad.t + plotH*gy/5; ctx.moveTo(pad.l,y); ctx.lineTo(pad.l+plotW,y); } ctx.stroke();
    ctx.fillStyle=ax; ctx.textAlign='right'; ctx.textBaseline='middle';
    for(let gy=0;gy<=5;gy++){ const v=ymin+(ymax-ymin)*gy/5; ctx.fillText((options&&options.formatY?options.formatY(v):v.toFixed(1)), pad.l-6, yTo(v)); }
    ctx.textAlign='center'; ctx.textBaseline='top';
    labels.forEach((lab,i)=> ctx.fillText(lab, xTo(i), pad.t+plotH+6));
    series.forEach((s,si)=>{
      ctx.lineWidth=2; ctx.strokeStyle=s.color||pal[si%pal.length]; ctx.setLineDash(s.dashed?[5,4]:[]);
      ctx.beginPath();
      s.data.forEach((v,i)=>{ if(v==null)return; const x=xTo(i), y=yTo(v); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
      ctx.stroke();
      if(!s.hidePoints){
        s.data.forEach((v,i)=>{ if(v==null)return; const x=xTo(i), y=yTo(v); ctx.fillStyle=s.color||pal[si%pal.length]; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); });
      }
    });
  }
  function drawSlopeVisual(canvas, labels, gradePctList){
    const dpr=Math.max(1,window.devicePixelRatio||1), w=canvas.clientWidth, h=canvas.clientHeight;
    canvas.width=Math.round(w*dpr); canvas.height=Math.round(h*dpr);
    const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,w,h);
    
    const pad={l:15,r:15,t:20,b:50};
    const plotW=w-pad.l-pad.r, plotH=h-pad.t-pad.b;
    const N = labels.length; if(N===0) return;
    const colW = plotW / N;
    
    // Create gradient backgrounds for terrain
    const groundGradient = ctx.createLinearGradient(0, pad.t + plotH * 0.7, 0, h);
    groundGradient.addColorStop(0, '#2d4a3a');
    groundGradient.addColorStop(0.3, '#1a2634');
    groundGradient.addColorStop(1, '#0b1118');
    
    // Draw background terrain
    ctx.fillStyle = groundGradient;
    ctx.fillRect(0, pad.t + plotH * 0.7, w, h - (pad.t + plotH * 0.7));
    
    // Add subtle grid lines
    ctx.strokeStyle = '#223040';
    ctx.lineWidth = 0.5;
    for(let i = 0; i <= N; i++) {
      const x = pad.l + (plotW * i / N);
      ctx.beginPath();
      ctx.moveTo(x, pad.t);
      ctx.lineTo(x, pad.t + plotH);
      ctx.stroke();
    }
    
    for(let i = 0; i < N; i++){
      const pct = gradePctList[i] || 0;
      const cx = pad.l + colW * (i + 0.5);
      const baseY = pad.t + plotH * 0.7;
      
      // Calculate slope dimensions
      const slopeLength = Math.min(colW * 0.7, 60);
      const theta = Math.atan(pct / 100);
      const rise = slopeLength * Math.sin(theta);
      const run = slopeLength * Math.cos(theta);
      
      // Create slope gradient based on grade difficulty
      const slopeGradient = ctx.createLinearGradient(cx - run/2, baseY - rise, cx + run/2, baseY);
      if(pct < 5) {
        slopeGradient.addColorStop(0, '#4da3ff');
        slopeGradient.addColorStop(1, '#2a6fbf');
      } else if(pct < 15) {
        slopeGradient.addColorStop(0, '#7dffb0');
        slopeGradient.addColorStop(1, '#4a9d6b');
      } else if(pct < 25) {
        slopeGradient.addColorStop(0, '#ffb84d');
        slopeGradient.addColorStop(1, '#d18a1c');
      } else {
        slopeGradient.addColorStop(0, '#ff6b6b');
        slopeGradient.addColorStop(1, '#c23333');
      }
      
      // Draw slope surface with 3D effect
      ctx.save();
      ctx.translate(cx, baseY);
      
      // Main slope surface
      ctx.fillStyle = slopeGradient;
      ctx.beginPath();
      ctx.moveTo(-run/2, 0);
      ctx.lineTo(run/2, -rise);
      ctx.lineTo(run/2 + 8, -rise + 4); // 3D depth
      ctx.lineTo(-run/2 + 8, 4); // 3D depth
      ctx.closePath();
      ctx.fill();
      
      // Slope edge highlight
      ctx.strokeStyle = pct < 5 ? '#6bb8ff' : (pct < 15 ? '#a0ffcc' : (pct < 25 ? '#ffc976' : '#ff9999'));
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-run/2, 0);
      ctx.lineTo(run/2, -rise);
      ctx.stroke();
      
      // Add road markings for realism
      if(slopeLength > 30) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 6]);
        ctx.beginPath();
        ctx.moveTo(-run/4, -rise/4);
        ctx.lineTo(run/4, -3*rise/4);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Shadow underneath
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.moveTo(-run/2 + 8, 4);
      ctx.lineTo(run/2 + 8, -rise + 4);
      ctx.lineTo(run/2 + 12, -rise + 8);
      ctx.lineTo(-run/2 + 12, 8);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
      
      // Enhanced labels with background
      const labelY = h - 35;
      const percentY = h - 18;
      
      // Label background
      ctx.fillStyle = 'rgba(11, 17, 24, 0.8)';
      ctx.roundRect(cx - 25, labelY - 12, 50, 28, 6);
      ctx.fill();
      
      // Gear label
      ctx.fillStyle = '#cfe2ff';
      ctx.font = '11px system-ui, sans-serif';
      ctx.fontWeight = '600';
      ctx.textAlign = 'center';
      ctx.fillText(labels[i], cx, labelY);
      
      // Grade percentage with color coding
      ctx.fillStyle = pct < 5 ? '#4da3ff' : (pct < 15 ? '#7dffb0' : (pct < 25 ? '#ffb84d' : '#ff6b6b'));
      ctx.font = 'bold 12px system-ui, sans-serif';
      ctx.fillText(`${pct.toFixed(0)}%`, cx, percentY);
      
      // Add small indicator arrow for very steep grades
      if(pct > 20) {
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.moveTo(cx + 20, labelY - 5);
        ctx.lineTo(cx + 26, labelY - 2);
        ctx.lineTo(cx + 20, labelY + 1);
        ctx.closePath();
        ctx.fill();
      }
    }
    
    // Add title with gradient
    ctx.fillStyle = '#a9b7c6';
    ctx.font = 'bold 13px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Maximum Climb Grade per Gear', pad.l, 15);
    
    // Add legend
    const legendX = w - 120;
    const legendY = 25;
    const legendItems = [
      {color: '#4da3ff', text: '< 5%'},
      {color: '#7dffb0', text: '5-15%'},
      {color: '#ffb84d', text: '15-25%'},
      {color: '#ff6b6b', text: '> 25%'}
    ];
    
    legendItems.forEach((item, i) => {
      ctx.fillStyle = item.color;
      ctx.fillRect(legendX, legendY + i * 12, 8, 8);
      ctx.fillStyle = '#a9b7c6';
      ctx.font = '10px system-ui, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(item.text, legendX + 12, legendY + i * 12 + 7);
    });
  }

  /* ---------- Sexy Gear Canvas Animation ---------- */
  let animId = null, lastT = 0, angFront = 0, angRear = 0, chainOffset = 0;

  function drawSprocket(ctx, x, y, baseR, teeth, angle, color){
    const toothH = 4, innerR = baseR-toothH, outerR = baseR+toothH;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle);
    ctx.lineWidth=2;
    ctx.shadowColor=color; ctx.shadowBlur=10;
    ctx.strokeStyle=color;
    ctx.beginPath(); ctx.arc(0,0,baseR,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle = color; ctx.globalAlpha=0.85;
    for(let i=0;i<teeth;i++){
      const a = i*2*Math.PI/teeth;
      const w = Math.max(4, (2*Math.PI*baseR/teeth)*0.25);
      ctx.save(); ctx.rotate(a);
      ctx.beginPath();
      ctx.moveTo(innerR, -w*0.5);
      ctx.lineTo(outerR, -w*0.3);
      ctx.lineTo(outerR,  w*0.3);
      ctx.lineTo(innerR,  w*0.5);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    ctx.globalAlpha=1;
    ctx.beginPath(); ctx.arc(0,0,innerR,0,Math.PI*2); ctx.strokeStyle="#1b2a40"; ctx.stroke();
    ctx.restore();
  }

  function drawChain(ctx, path, linkSpacing, offset, color){
    ctx.save();
    ctx.fillStyle=color; ctx.shadowColor=color; ctx.shadowBlur=6;
    const totalLen = path.reduce((s,seg)=>s+Math.hypot(seg.x2-seg.x1, seg.y2-seg.y1),0);
    let s0 = (-offset % linkSpacing + linkSpacing) % linkSpacing;
    for(let s=s0; s<totalLen; s+=linkSpacing){
      let d = s;
      for(const seg of path){
        const L = Math.hypot(seg.x2-seg.x1, seg.y2-seg.y1);
        if(d<=L){
          const t = d/L;
          const x = seg.x1 + (seg.x2-seg.x1)*t;
          const y = seg.y1 + (seg.y2-seg.y1)*t;
          const ang = Math.atan2(seg.y2-seg.y1, seg.x2-seg.x1);
          const w=10, h=3;
          ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
          ctx.globalAlpha=0.95; ctx.fillRect(-w/2,-h/2,w,h);
          ctx.restore();
          break;
        } else { d-=L; }
      }
    }
    ctx.restore();
  }

  function drawGearCanvas(rears){
    const canvas = $('#gearCanvas');
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
    const ctx = canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);

    if(!rears.length) return;
    const frontT = parseInt($('#frontTeeth').value,10)||40;
    const rearT  = rears[gearIndex];
    const circ   = getCirc();
    const visRpm = Math.max(0, parseFloat($('#visRpmNum').value)||1);

    // Calculate proper scaling - use actual tooth proportions
    const maxTeeth = Math.max(frontT, rearT);
    const baseRadius = Math.min(120, Math.max(80, Math.min(w, h) * 0.15));
    const rFront = baseRadius * (frontT / maxTeeth);
    const rRear  = baseRadius * (rearT / maxTeeth);

    // Position cogs with proper spacing based on actual radii
    const spacing = rFront + rRear + 60; // More spacing for chain clearance
    const leftX = w/2 - spacing/2;
    const rightX = w/2 + spacing/2;
    const centerY = h/2;

    const ratio = frontT/rearT;
    const wheelRpm = visRpm * ratio;

    // Calculate actual max speed considering both limits
    const m = parseFloat($('#mass').value) || 160;
    const Crr = 0.006;
    const CdA = 0.60;
    const rho = 1.20;
    const riderW = Math.max(0, parseFloat($('#riderW').value) || 0);
    const V = parseFloat($('#voltage').value) || 52;
    const A = parseFloat($('#current').value) || 30;
    const motorEff = Math.min(1, Math.max(0, parseFloat($('#motorEff').value) || 0.82));
    const maxCad = parseFloat($('#maxCadence').value) || 140;
    const mode = $('#powerMode').value;
    
    let P_mech = 0;
    if(mode === 'va') {
      P_mech = V * A * motorEff;
    } else {
      P_mech = Math.max(0, parseFloat($('#mechW').value) || 0);
    }
    P_mech += riderW;

    // Power-limited top speed
    const vFlat = binSearchTopSpeedFlat(P_mech, m, Crr, rho, CdA);
    const topFlatMph = vFlat * MPH_PER_MPS;
    
    // RPM-limited top speed for current gear
    const topGearRpmMps = (maxCad * ratio * circ / 60);
    const topGearRpmMph = topGearRpmMps * MPH_PER_MPS;
    
    // Actual top speed is the minimum of both limits
    const actualTopMph = Math.min(topFlatMph, topGearRpmMph);
    const actualTopDisp = mphToDisplay(actualTopMph);

    // Current speed from visualizer
    const currentSpeedMps = (wheelRpm/60) * circ;
    const currentSpeedDisp = mpsToDisplay(currentSpeedMps);

    // Calculate proper tangent points for chain wrapping
    const dx = rightX - leftX;
    const dy = 0; // Same height
    const distance = Math.sqrt(dx*dx + dy*dy);
    
    // External tangent angles (for top and bottom chains)
    const dr = rRear - rFront;
    const angle = Math.asin(dr / distance);
    
    // Top chain tangent points
    const topAngle = -Math.PI/2 + angle;
    const topFrontX = leftX + rFront * Math.cos(topAngle);
    const topFrontY = centerY + rFront * Math.sin(topAngle);
    const topRearX = rightX + rRear * Math.cos(topAngle);
    const topRearY = centerY + rRear * Math.sin(topAngle);
    
    // Bottom chain tangent points
    const bottomAngle = Math.PI/2 + angle;
    const bottomFrontX = leftX + rFront * Math.cos(bottomAngle);
    const bottomFrontY = centerY + rFront * Math.sin(bottomAngle);
    const bottomRearX = rightX + rRear * Math.cos(bottomAngle);
    const bottomRearY = centerY + rRear * Math.sin(bottomAngle);

    // Create complete chain path with arcs around back of sprockets
    const chainPath = [];
    
    // Top straight segment
    chainPath.push({x1: topFrontX, y1: topFrontY, x2: topRearX, y2: topRearY});
    
    // Arc around back of rear sprocket (clockwise from top to bottom)
    const rearArcSteps = Math.max(8, Math.ceil(rRear / 6));
    const rearStartAngle = topAngle;
    const rearEndAngle = bottomAngle;
    let rearAngleSpan = rearEndAngle - rearStartAngle;
    if(rearAngleSpan < 0) rearAngleSpan += 2*Math.PI;
    
    for(let i = 0; i < rearArcSteps; i++) {
      const t1 = i / rearArcSteps;
      const t2 = (i + 1) / rearArcSteps;
      const a1 = rearStartAngle + t1 * rearAngleSpan;
      const a2 = rearStartAngle + t2 * rearAngleSpan;
      chainPath.push({
        x1: rightX + rRear * Math.cos(a1),
        y1: centerY + rRear * Math.sin(a1),
        x2: rightX + rRear * Math.cos(a2),
        y2: centerY + rRear * Math.sin(a2)
      });
    }
    
    // Bottom straight segment (right to left)
    chainPath.push({x1: bottomRearX, y1: bottomRearY, x2: bottomFrontX, y2: bottomFrontY});
    
    // Arc around back of front sprocket (clockwise from bottom to top)
    const frontArcSteps = Math.max(8, Math.ceil(rFront / 6));
    const frontStartAngle = bottomAngle;
    const frontEndAngle = topAngle;
    // Calculate the larger arc (going the back way around)
    let frontAngleSpan = frontEndAngle - frontStartAngle;
    if(frontAngleSpan > 0) frontAngleSpan -= 2*Math.PI; // Make it negative to go the long way
    frontAngleSpan = Math.abs(frontAngleSpan);
    
    for(let i = 0; i < frontArcSteps; i++) {
      const t1 = i / frontArcSteps;
      const t2 = (i + 1) / frontArcSteps;
      // Go clockwise around the back
      const a1 = frontStartAngle + t1 * frontAngleSpan;
      const a2 = frontStartAngle + t2 * frontAngleSpan;
      chainPath.push({
        x1: leftX + rFront * Math.cos(a1),
        y1: centerY + rFront * Math.sin(a1),
        x2: leftX + rFront * Math.cos(a2),
        y2: centerY + rFront * Math.sin(a2)
      });
    }

    // Draw sprockets
    drawSprocket(ctx, leftX, centerY, rFront, frontT, angFront, "#4da3ff");
    drawSprocket(ctx, rightX, centerY, rRear, rearT, angRear, "#ffb84d");

    // Draw complete chain loop
    drawChain(ctx, chainPath, 10, chainOffset, "#8fd0ff");

    // Simple labels only
    ctx.fillStyle='#a9b7c6'; ctx.font='12px system-ui,sans-serif'; ctx.textAlign='center';
    ctx.fillText(`${frontT}T`, leftX, centerY - rFront - 12);
    ctx.fillText(`${rearT}T`, rightX, centerY - rRear - 12);
    
    // Speed display under rear cog
    ctx.fillStyle='#b9ffdb';
    ctx.font='13px system-ui,sans-serif';
    ctx.fillText(`${currentSpeedDisp.toFixed(1)} ${unitLabel()}`, rightX, centerY + rRear + 20);
    
    // Max speed indicator
    ctx.fillStyle='#7dffb0';
    ctx.font='11px system-ui,sans-serif';
    ctx.fillText(`Max: ${actualTopDisp.toFixed(1)} ${unitLabel()}`, rightX, centerY + rRear + 34);
  }

  function updateGearVisualizer(rears){
    if(!rears.length) return;
    gearIndex = clampGear(gearIndex, rears);
    const front=parseInt($('#frontTeeth').value,10) || 40;
    const visRpm = parseFloat($('#visRpmNum').value)||1;
    const rear = rears[gearIndex];
    const ratio = front / rear;
    const circ=getCirc();
    const wheel_rpm = ratio * visRpm;
    const speed_mps = (wheel_rpm/60) * circ;
    const speed_disp = mpsToDisplay(speed_mps);
    
    $('#gv_label').textContent = `Gear ${gearIndex+1}/${rears.length} ‚Äî ${front}/${rear}T`;
    $('#gv_ratio').textContent = `ratio = front/rear = ${front}/${rear} = ${ratio.toFixed(2)}√ó`;
    $('#gv_frontT').textContent = `${front}T ring`;
    $('#gv_crank_rpm').textContent = `${visRpm.toFixed(2)} rpm`;
    $('#gv_wheel_rpm').textContent = `${wheel_rpm.toFixed(2)} rpm`;
    $('#gv_speed').textContent = `${speed_disp.toFixed(2)} ${unitLabel()}`;
    drawGearCanvas(parseRear($('#rearCogs').value));
  }

  function updateGearButtons(rears){
    $('#gearDown').disabled = (gearIndex <= 0);
    $('#gearUp').disabled = (gearIndex >= rears.length - 1);
  }

  /* ---------- Main compute ---------- */
  function compute(){
    const circ=getCirc(), radius=circ/(2*Math.PI);
    const front=parseInt($('#frontTeeth').value,10);
    const rears=parseRear($('#rearCogs').value);

    if(firstCompute){ gearIndex = Math.max(0, Math.floor(rears.length/2)); firstCompute=false; }
    gearIndex = clampGear(gearIndex, rears);

    const m   = parseFloat($('#mass').value);
    const Crr = 0.006;
    const CdA = 0.60;
    const rho = 1.20;
    const riderW = Math.max(0, parseFloat($('#riderW').value));
    const Tcrank = parseFloat($('#crankTorque').value);
    const chainEff = parseFloat($('#driveEff').value);
    const V   = parseFloat($('#voltage').value);
    const A   = parseFloat($('#current').value);
    const motorEff = Math.min(1, Math.max(0, parseFloat($('#motorEff').value)));
    const maxCad = parseFloat($('#maxCadence').value);
    const climbMph = getSpeedInputMph('climbMph');
    const vclimb = climbMph*MPS_PER_MPH;

    const mode=$('#powerMode').value;
    let P_mech=0, P_batt=0;
    if(mode==='va'){ P_batt=V*A; P_mech=P_batt*motorEff; } else { P_mech=Math.max(0,parseFloat($('#mechW').value)||0); P_batt=P_mech/Math.max(0.01,motorEff); }
    P_mech += riderW;

    const vFlat = binSearchTopSpeedFlat(P_mech, m, Crr, rho, CdA);
    const topFlatMph = vFlat*MPH_PER_MPS;

    const labels=rears.map(t=>t+'T');
    const speedTopDisp=[], torqueNm=[], gradeTorque=[], gradeActual=[];
    const rows=[];

    const reqN_power = (P_mech/vclimb) - 0.5*rho*CdA*vclimb*vclimb;
    const gPower = (reqN_power/(m*g)) - Crr;
    const gPowerPct = Math.max(0, gPower*100);

    rears.forEach(rear=>{
      const ratio=front/rear;
      const speed_mps_rpm_limited = maxCad*ratio*circ/60;
      const speed_mph_rpm_limited = speed_mps_rpm_limited * MPH_PER_MPS;
      const speed_mph_power_limited = topFlatMph;
      
      // Actual top speed is the minimum of both limits
      const actual_top_speed_mph = Math.min(speed_mph_rpm_limited, speed_mph_power_limited);
      const top_disp = mpsToDisplay(actual_top_speed_mph * MPS_PER_MPH);
      
      const Tw = Tcrank*(rear/front)*chainEff;
      const thrust = Tw / radius;
      const gTorque = ((thrust - 0.5*rho*CdA*vclimb*vclimb)/(m*g)) - Crr;
      const gTorquePct = Math.max(0,gTorque*100);
      const gActualPct = Math.max(0, Math.min(gTorquePct, gPowerPct));

      rows.push({gear:`${front}/${rear}`, ratio:(front/rear).toFixed(2), top:top_disp.toFixed(1), tw:Tw.toFixed(1),
                 gt:gTorquePct.toFixed(1)+'%', ga:gActualPct.toFixed(1)+'%'});

      speedTopDisp.push(top_disp); torqueNm.push(Tw); gradeTorque.push(gTorquePct); gradeActual.push(gActualPct);
    });

    const topRear = rears[0]||13;
    const topGearRpmMps = (maxCad*(front/topRear)*circ/60);
    const topGearRpmDisp = mpsToDisplay(topGearRpmMps);
    const overallTop = Math.min(topGearRpmDisp, mphToDisplay(topFlatMph));

    $('#summary').innerHTML = `
      <div><span class="badge">Wheel</span> circumference ‚âà <b>${(circ*1000).toFixed(0)} mm</b></div>
      <div style="margin-top:4px"><span class="badge">Power</span> mech <b>${fmt(P_mech,0)} W</b> (incl. rider ${fmt(riderW,0)} W) ‚Ä¢ battery draw ‚âà <b>${fmt(P_batt,0)} W</b>.</div>
      <div style="margin-top:4px"><span class="badge">Top speed</span> flat power-limit <b>${fmt(mphToDisplay(topFlatMph),1)} ${unitLabel()}</b> ‚Ä¢ top-gear rpm-limit <b>${fmt(topGearRpmDisp,1)} ${unitLabel()}</b> ‚Üí <b>overall ‚âà ${fmt(overallTop,1)} ${unitLabel()}</b></div>
      <div style="margin-top:4px"><span class="badge">Power-limited grade @ ${fmt(mphToDisplay(climbMph),1)} ${unitLabel()}</span> <b>${fmt(gPowerPct,1)}%</b> (gear-independent)</div>
    `;

    const ratios = rears.map(r=>front/r).sort((a,b)=>a-b);
    const gearRange = ratios[ratios.length-1] / ratios[0];
    let steps=[]; for(let i=1;i<ratios.length;i++){ steps.push((ratios[i]/ratios[i-1]-1)*100); }
    const avgStep = steps.length? (steps.reduce((a,b)=>a+b,0)/steps.length) : 0;
    $('#gearSummary').innerHTML = `
      <div><span class="badge">Ratio range</span> <b>${fmt(gearRange,2)}√ó</b> (low ${fmt(ratios[0],2)} ‚Üí high ${fmt(ratios[ratios.length-1],2)})</div>
      <div style="margin-top:4px"><span class="badge">Avg step</span> ${fmt(avgStep,1)}% between adjacent gears</div>
    `;

    const tbody=$('#resultTable tbody');
    tbody.innerHTML = rows.map((r,i)=>`<tr data-gi="${i}"><td>${r.gear}</td><td>${r.ratio}</td><td>${r.top}</td><td>${r.tw}</td><td>${r.gt}</td><td>${r.ga}</td></tr>`).join('');
    highlightSelectedRow();

    drawChart($('#chartSpeed'), labels, [
      {name:`Top speed (${unitLabel()})`, data:speedTopDisp, color:'#4da3ff'},
      {name:`Flat power-limit (${unitLabel()})`, data:labels.map(_=>mphToDisplay(topFlatMph)), color:'#7dffb0', dashed:true, hidePoints:true}
    ], {title:`Top Speed per Gear (${unitLabel()}) - Actual (min of power & RPM limits)`, formatY:v=>v.toFixed(0)});

    drawChart($('#chartTorque'), labels, [
      {name:'Wheel torque (Nm)', data:torqueNm, color:'#ffb84d'}
    ], {title:'Wheel Torque per Gear', formatY:v=>v.toFixed(0)+' Nm'});

    drawChart($('#chartGrade'), labels, [
      {name:'Max grade (actual @v)', data:gradeActual, color:'#7dffb0'},
      {name:'Torque-limited @v', data:gradeTorque, color:'#4da3ff', dashed:true},
      {name:'Power-limited @v (global)', data:labels.map(_=>gPowerPct), color:'#ff6b6b', dashed:true, hidePoints:true}
    ], {title:`Max Grade at ${fmt(mphToDisplay(climbMph),1)} ${unitLabel()} (per gear)`, formatY:v=>v.toFixed(0)+'%'});

    drawSlopeVisual($('#chartSlope'), labels, gradeActual);
    updateGearVisualizer(rears);
    updateGearButtons(rears);
    calcRange();
  }

  /* ---------- Range box ---------- */
  function calcRange(){
    const batAh = parseFloat($('#batAh').value)||0;
    const usablePct = Math.min(100, Math.max(0, parseFloat($('#usablePct').value)||0));
    const V = parseFloat($('#voltage').value)||0;
    const motorEff = Math.min(1, Math.max(0, parseFloat($('#motorEff').value)||0));
    const riderW = Math.max(0, parseFloat($('#riderW').value)||0);
    const m = parseFloat($('#mass').value)||0;
    const Crr = 0.006;
    const CdA = 0.60;
    const rho = 1.20;
    const cruiseMph = getSpeedInputMph('rangeMph');
    const v = cruiseMph*MPS_PER_MPH;
    const grade = (parseFloat($('#rangeGradePct').value)||0)/100;

    const usableWh = batAh * V * (usablePct/100);
    const Paero = 0.5*rho*CdA*v*v*v;
    const Proll = m*g*Crr*v;
    const Pgrav = m*g*grade*v;
    const Ptotal = Paero + Proll + Pgrav;
    const Pmotor_mech = Math.max(0, Ptotal - riderW);
    const P_batt = motorEff>0 ? Pmotor_mech / motorEff : Infinity;

    let text='';
    if(!isFinite(P_batt) || P_batt<=0 || usableWh<=0 || v<=0){
      text = `<div class="no">Insufficient data for range (check battery, efficiency and speed).</div>`;
    } else {
      const hours = usableWh / P_batt;
      const dist_miles = hours * cruiseMph;
      const dist_km = dist_miles * 1.609344;
      const h = Math.floor(hours);
      const mins = Math.floor((hours - h)*60);
      text = `
        <div><span class="badge">Usable energy</span> <b>${fmt(usableWh,0)} Wh</b></div>
        <div style="height:6px"></div>
        <div><span class="badge">Cruise @ ${fmt(mphToDisplay(cruiseMph),1)} ${unitLabel()}, grade ${fmt(grade*100,1)}%</span> 
          battery draw ‚âà <b>${fmt(P_batt,0)} W</b> ‚Ä¢ ride time ‚âà <b>${h}h ${mins}m</b></div>
        <div style="margin-top:4px"><span class="badge">Estimated range</span> <b>${fmt(dist_miles,1)} mi</b> / <b>${fmt(dist_km,1)} km</b></div>
        <div class="small muted" style="margin-top:4px">Includes rider watts; assumes steady conditions, no starts/stops, no wind.</div>
      `;
    }
    $('#rangeBox').innerHTML = text;
  }

  /* ---------- Solver & Uncertainty ---------- */
  function designSystem(){
    const requirements = {
      weight: $('#req_weight').checked ? parseFloat($('#sys_weight').value) : null,
      topSpeed: $('#req_topSpeed').checked ? getSpeedInputFromDisplay($('#sys_topSpeed').value) : null,
      climbSpeed: $('#req_climbSpeed').checked ? getSpeedInputFromDisplay($('#sys_climbSpeed').value) : null,
      climbGrade: $('#req_climbGrade').checked ? parseFloat($('#sys_climbGrade').value) / 100 : null,
      range: $('#req_range').checked ? (speedUnit === 'mph' ? parseFloat($('#sys_range').value) : parseFloat($('#sys_range').value) / 1.609344) : null,
      rangeSpeed: $('#req_rangeSpeed').checked ? getSpeedInputFromDisplay($('#sys_rangeSpeed').value) : null,
      rangeGrade: $('#req_rangeGrade').checked ? parseFloat($('#sys_rangeGrade').value) / 100 : null
    };
    
    const constraints = {
      wheelCirc: parseFloat($('#sys_wheelSize').value) / 1000,
      riderWatts: parseFloat($('#sys_riderWatts').value),
      chainringMin: parseFloat($('#sys_chainringMin').value) || 32,
      chainringMax: parseFloat($('#sys_chainringMax').value) || 52,
      maxRpm: parseFloat($('#sys_maxRpm').value),
      driveEff: parseFloat($('#sys_efficiency').value),
      motorEff: parseFloat($('#sys_motorEff').value),
      batteryV: parseFloat($('#sys_batteryV').value)
    };
    
    // Physics constants
    const g = 9.80665;
    const Crr = 0.006; // Rolling resistance
    const CdA = 0.60;  // Aerodynamic drag
    const rho = 1.20;  // Air density
    const radius = constraints.wheelCirc / (2 * Math.PI);
    
    // Required power calculations
    let minMotorPower = 0;
    let minTorque = 0;
    let minBatteryAh = 0;
    let suggestedGearing = {};
    let report = [];
    
    // 1. Top speed requirement
    if (requirements.topSpeed) {
      const vTop = requirements.topSpeed * MPS_PER_MPH;
      const mass = requirements.weight || 160;
      
      // Power needed for top speed (aerodynamic + rolling)
      const Paero = 0.5 * rho * CdA * vTop * vTop * vTop;
      const Proll = mass * g * Crr * vTop;
      const PtopTotal = Paero + Proll;
      const PtopMotor = Math.max(0, PtopTotal - constraints.riderWatts);
      
      minMotorPower = Math.max(minMotorPower, PtopMotor);
      
      // Gearing for top speed
      const topRatio = (vTop * 60) / (constraints.maxRpm * constraints.wheelCirc);
      suggestedGearing.topSpeedRatio = topRatio;
      
      report.push(`<div><span class="badge">Top Speed</span> ${fmt(mphToDisplay(requirements.topSpeed), 1)} ${unitLabel()} needs ‚â•<b>${fmt(PtopMotor, 0)}W</b> motor power, gear ratio ‚â§<b>${fmt(topRatio, 2)}</b></div>`);
    }
    
    // 2. Climb requirement
    if (requirements.climbSpeed && requirements.climbGrade) {
      const vClimb = requirements.climbSpeed * MPS_PER_MPH;
      const grade = requirements.climbGrade;
      const mass = requirements.weight || 160;
      
      // Power needed for climbing
      const Paero = 0.5 * rho * CdA * vClimb * vClimb * vClimb;
      const Proll = mass * g * Crr * vClimb;
      const Pgrav = mass * g * grade * vClimb;
      const PclimbTotal = Paero + Proll + Pgrav;
      const PclimbMotor = Math.max(0, PclimbTotal - constraints.riderWatts);
      
      minMotorPower = Math.max(minMotorPower, PclimbMotor);
      
      // Torque needed for climbing
      const thrustNeeded = Math.max(0, PclimbTotal - constraints.riderWatts) / vClimb;
      const wheelTorqueNeeded = thrustNeeded * radius;
      const crankTorqueNeeded = wheelTorqueNeeded / constraints.driveEff;
      
      minTorque = Math.max(minTorque, crankTorqueNeeded);
      
      report.push(`<div><span class="badge">Climbing</span> ${fmt(grade * 100, 1)}% at ${fmt(mphToDisplay(requirements.climbSpeed), 1)} ${unitLabel()} needs ‚â•<b>${fmt(PclimbMotor, 0)}W</b> motor power, ‚â•<b>${fmt(crankTorqueNeeded, 0)}Nm</b> crank torque</div>`);
    }
    
    // 3. Range requirement
    if (requirements.range && requirements.rangeSpeed) {
      const vRange = requirements.rangeSpeed * MPS_PER_MPH;
      const mass = requirements.weight || 160;
      const rangeGrade = requirements.rangeGrade || 0;
      
      // Power needed for range cruise
      const Paero = 0.5 * rho * CdA * vRange * vRange * vRange;
      const Proll = mass * g * Crr * vRange;
      const Pgrav = mass * g * rangeGrade * vRange;
      const PrangeTotal = Paero + Proll + Pgrav;
      const PrangeMotor = Math.max(0, PrangeTotal - constraints.riderWatts);
      const PrangeBattery = PrangeMotor / constraints.motorEff;
      
      // Battery capacity needed
      const hours = requirements.range / requirements.rangeSpeed;
      const WhNeeded = PrangeBattery * hours;
      const AhNeeded = WhNeeded / constraints.batteryV;
      
      minBatteryAh = Math.max(minBatteryAh, AhNeeded);
      
      report.push(`<div><span class="badge">Range</span> ${fmt(mphToDisplay(requirements.range), 0)} ${speedUnit === 'mph' ? 'mi' : 'km'} at ${fmt(mphToDisplay(requirements.rangeSpeed), 1)} ${unitLabel()} needs ‚â•<b>${fmt(AhNeeded, 1)}Ah</b> battery (${fmt(WhNeeded, 0)}Wh)</div>`);
    }
    
    const batteryAmp = (minMotorPower / constraints.motorEff) / constraints.batteryV;
    
    // Suggest specific gearing
    if (suggestedGearing.topSpeedRatio) {
      // Calculate required gear ratios for both top speed and climbing
      const topSpeedRatio = suggestedGearing.topSpeedRatio;
      
      // Calculate climbing ratio requirement
      let climbRatio = null;
      if (requirements.climbSpeed && requirements.climbGrade && minTorque > 0) {
        const vClimb = requirements.climbSpeed * MPS_PER_MPH;
        const grade = requirements.climbGrade;
        const mass = requirements.weight || 160;
        
        // Required thrust for climbing
        const Paero = 0.5 * rho * CdA * vClimb * vClimb * vClimb;
        const Proll = mass * g * Crr * vClimb;
        const Pgrav = mass * g * grade * vClimb;
        const PclimbTotal = Paero + Proll + Pgrav;
        const thrustNeeded = Math.max(0, PclimbTotal - constraints.riderWatts) / vClimb;
        const wheelTorqueNeeded = thrustNeeded * radius;
        
        // Assume a reasonable crank torque if we need to estimate
        const estimatedCrankTorque = minTorque || 160;
        const maxWheelTorque = estimatedCrankTorque * constraints.driveEff;
        
        // Required gear ratio for climbing (front/rear)
        climbRatio = maxWheelTorque / wheelTorqueNeeded;
      }
      
      // Find suitable chainring and cassette
      let bestGearing = null;
      const minChainring = Math.max(constraints.chainringMin, 32);
      const maxChainring = Math.min(constraints.chainringMax, 52);
      
      for (let chainring = minChainring; chainring <= maxChainring; chainring += 2) {
        // Calculate required rear cog sizes
        const smallestRear = Math.max(11, Math.ceil(chainring / topSpeedRatio));
        let largestRear = 50; // Default maximum
        
        if (climbRatio) {
          largestRear = Math.min(50, Math.ceil(chainring / climbRatio));
        }
        
        // Check if this creates a reasonable cassette range
        if (smallestRear <= largestRear && smallestRear <= 16 && largestRear >= 28) {
          // Adjust to realistic cassette options
          const adjustedSmall = smallestRear <= 11 ? 11 : (smallestRear <= 13 ? 13 : 16);
          const adjustedLarge = largestRear >= 42 ? 42 : (largestRear >= 34 ? 34 : 28);
          
          if (adjustedSmall <= adjustedLarge) {
            bestGearing = { 
              chainring, 
              minRear: adjustedSmall, 
              maxRear: adjustedLarge,
              topSpeedCheck: chainring / adjustedSmall >= topSpeedRatio ? '‚úì' : '‚úó',
              climbCheck: climbRatio ? (chainring / adjustedLarge <= climbRatio ? '‚úì' : '‚úó') : '‚Äî'
            };
            break;
          }
        }
      }
      
      if (bestGearing) {
        const topSpeedActual = (bestGearing.chainring / bestGearing.minRear);
        const climbActual = climbRatio ? (bestGearing.chainring / bestGearing.maxRear) : null;
        
        let recommendation = `${bestGearing.chainring}T chainring with ${bestGearing.minRear}-${bestGearing.maxRear}T cassette`;
        
        // Add validation info
        let validation = '<div class="small muted" style="margin-top: 4px;">';
        validation += `Top speed ratio: need ‚â§${topSpeedRatio.toFixed(2)}, get ${topSpeedActual.toFixed(2)} ${bestGearing.topSpeedCheck}`;
        if (climbRatio) {
          validation += `<br>Climb ratio: need ‚â•${climbRatio.toFixed(2)}, get ${climbActual.toFixed(2)} ${bestGearing.climbCheck}`;
        }
        validation += '</div>';
        
        suggestedGearing.recommendation = recommendation + validation;
      } else {
        // Provide more specific guidance
        const needSmallest = Math.ceil(minChainring / topSpeedRatio);
        const needLargest = climbRatio ? Math.ceil(maxChainring / climbRatio) : null;
        
        let guidance = `Difficult to meet requirements with chainring range ${constraints.chainringMin}-${constraints.chainringMax}T. `;
        guidance += `Top speed needs rear cog ‚â•${needSmallest}T. `;
        if (needLargest) {
          guidance += `Climbing needs rear cog ‚â•${needLargest}T. `;
        }
        guidance += 'Consider wider chainring range or adjust targets.';
        
        suggestedGearing.recommendation = guidance;
      }
    }
    
    // Generate comprehensive report
    let output = `<div style="background: rgba(125,255,176,0.1); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
      <div style="font-weight: 600; color: var(--accent); margin-bottom: 8px;">Minimum System Requirements</div>
      ${report.join('')}
    </div>`;
    
    if (minMotorPower > 0) {
      output += `<div style="background: rgba(77,163,255,0.1); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
        <div style="font-weight: 600; color: var(--accent); margin-bottom: 8px;">Motor Specifications</div>
        <div><span class="badge">Power</span> ‚â•<b>${fmt(minMotorPower, 0)}W</b> mechanical (‚â•<b>${fmt(minMotorPower / constraints.motorEff, 0)}W</b> electrical)</div>
        ${minTorque > 0 ? `<div><span class="badge">Torque</span> ‚â•<b>${fmt(minTorque, 0)}Nm</b> at crank</div>` : ''}
        <div><span class="badge">Max RPM</span> ‚â•<b>${constraints.maxRpm}</b> (as specified)</div>
      </div>`;
    }
    
    if (minBatteryAh > 0 || batteryAmp > 0) {
      output += `<div style="background: rgba(255,184,77,0.1); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
        <div style="font-weight: 600; color: var(--warn); margin-bottom: 8px;">Battery & Controller</div>
        <div><span class="badge">Voltage</span> <b>${constraints.batteryV}V</b> (as specified)</div>
        ${batteryAmp > 0 ? `<div><span class="badge">Controller</span> ‚â•<b>${fmt(batteryAmp, 1)}A</b> continuous current</div>` : ''}
        ${minBatteryAh > 0 ? `<div><span class="badge">Capacity</span> ‚â•<b>${fmt(minBatteryAh, 1)}Ah</b> (‚â•<b>${fmt(minBatteryAh * constraints.batteryV, 0)}Wh</b>)</div>` : ''}
      </div>`;
    }
    
    if (suggestedGearing.recommendation) {
      output += `<div style="background: rgba(196,139,255,0.1); padding: 12px; border-radius: 8px;">
        <div style="font-weight: 600; color: #c48bff; margin-bottom: 8px;">Recommended Gearing</div>
        <div><span class="badge">Drivetrain</span> <b>${suggestedGearing.recommendation}</b></div>
        <div class="small muted" style="margin-top: 4px;">Based on chainring range ${constraints.chainringMin}-${constraints.chainringMax}T and standard cassette options</div>
      </div>`;
    }
    
    if (report.length === 0) {
      output = `<div class="no">No requirements selected. Check the boxes next to requirements you want to enforce.</div>`;
    }
    
    $('#designOut').innerHTML = output;
  }

  function runRobustnessAnalysis(){
    const N = Math.max(50, parseInt($('#N').value) || 500);
    
    // Get current system specs (use main form values)
    const baseSpecs = {
      mass: parseFloat($('#mass').value) || 160,
      frontTeeth: parseInt($('#frontTeeth').value) || 40,
      rearCogs: parseRear($('#rearCogs').value),
      voltage: parseFloat($('#voltage').value) || 52,
      current: parseFloat($('#current').value) || 30,
      motorEff: parseFloat($('#motorEff').value) || 0.82,
      crankTorque: parseFloat($('#crankTorque').value) || 160,
      maxCadence: parseFloat($('#maxCadence').value) || 140,
      driveEff: parseFloat($('#driveEff').value) || 0.95,
      riderW: parseFloat($('#riderW').value) || 0,
      wheelCirc: getCirc()
    };
    
    // Variation percentages
    const variations = {
      mass: parseFloat($('#var_mass').value) / 100,
      aero: parseFloat($('#var_aero').value) / 100,
      rolling: parseFloat($('#var_rolling').value) / 100,
      torque: parseFloat($('#var_torque').value) / 100,
      power: parseFloat($('#var_power').value) / 100,
      efficiency: parseFloat($('#var_efficiency').value) / 100
    };
    
    // Compute baseline achievable top speeds locally
    const powerMode = $('#powerMode').value;
    let baseMechPower = 0;
    if (powerMode === 'va') {
      baseMechPower = baseSpecs.voltage * baseSpecs.current * baseSpecs.motorEff;
    } else {
      baseMechPower = Math.max(0, parseFloat($('#mechW').value) || 0);
    }
    baseMechPower += baseSpecs.riderW;
    
    // Baseline top speeds
    const vFlatBase = binSearchTopSpeedFlat(baseMechPower, baseSpecs.mass, 0.006, 1.20, 0.60);
    const topFlatMphBase = vFlatBase * MPH_PER_MPS;
    const minRear = Math.min(...baseSpecs.rearCogs);
    const topGearRpmMpsBase = (baseSpecs.maxCadence * (baseSpecs.frontTeeth / minRear) * baseSpecs.wheelCirc) / 60;
    const topGearRpmMphBase = topGearRpmMpsBase * MPH_PER_MPS;
    
    // Test targets (use achievable top speed as target)
    const targets = {
      topSpeed: Math.min(topFlatMphBase, topGearRpmMphBase),
      climbGrade: 15, // 15% grade
      climbSpeed: getSpeedInputMph('climbMph')
    };
    
    function randomVariation(base, variation) {
      return base * (1 + (Math.random() - 0.5) * 2 * variation);
    }
    
    let successCount = 0;
    const failures = { power: 0, torque: 0, rpm: 0, total: 0 };
    
    for (let i = 0; i < N; i++) {
      // Apply random variations
      const scenario = {
        mass: randomVariation(baseSpecs.mass, variations.mass),
        Crr: randomVariation(0.006, variations.rolling),
        CdA: randomVariation(0.60, variations.aero),
        motorPower: randomVariation(baseMechPower - baseSpecs.riderW, variations.power) + baseSpecs.riderW,
        crankTorque: randomVariation(baseSpecs.crankTorque, variations.torque),
        driveEff: Math.min(0.98, randomVariation(baseSpecs.driveEff, variations.efficiency)),
        motorEff: Math.min(0.95, randomVariation(baseSpecs.motorEff, variations.efficiency))
      };
      
      // Test scenario against targets
      let scenarioPass = true;
      
      // 1. Test climb capability
      const vClimb = targets.climbSpeed * MPS_PER_MPH;
      const grade = targets.climbGrade / 100;
      
      // Power requirement
      const Paero = 0.5 * 1.20 * scenario.CdA * vClimb * vClimb * vClimb;
      const Proll = scenario.mass * g * scenario.Crr * vClimb;
      const Pgrav = scenario.mass * g * grade * vClimb;
      const PneededTotal = Paero + Proll + Pgrav - baseSpecs.riderW;
      
      if (PneededTotal > (scenario.motorPower - baseSpecs.riderW)) {
        scenarioPass = false;
        failures.power++;
      }
      
      // Torque requirement
      const thrustNeeded = Math.max(0, PneededTotal) / vClimb;
      const wheelTorqueNeeded = thrustNeeded * (baseSpecs.wheelCirc / (2 * Math.PI));
      const crankTorqueNeeded = wheelTorqueNeeded / scenario.driveEff;
      
      if (crankTorqueNeeded > scenario.crankTorque) {
        scenarioPass = false;
        failures.torque++;
      }
      
      // RPM feasibility for top speed
      const topSpeedMps = binSearchTopSpeedFlat(scenario.motorPower, scenario.mass, scenario.Crr, 1.20, scenario.CdA);
      const topSpeedMph = topSpeedMps * MPH_PER_MPS;
      
      // Check if the top gear can actually achieve the power-limited top speed
      const maxRatioForSpeed = (topSpeedMps * 60) / (baseSpecs.maxCadence * baseSpecs.wheelCirc);
      const actualTopRatio = baseSpecs.frontTeeth / minRear;
      
      // Only fail RPM test if the gear ratio prevents reaching the power-limited speed
      // AND the power-limited speed is above our target
      if (actualTopRatio > maxRatioForSpeed && topSpeedMph >= targets.topSpeed) {
        scenarioPass = false;
        failures.rpm++;
      }
      
      if (scenarioPass) successCount++;
    }
    
    const successRate = (successCount / N) * 100;
    
    let output = `<div style="background: ${successRate > 90 ? 'rgba(125,255,176,0.1)' : successRate > 70 ? 'rgba(255,184,77,0.1)' : 'rgba(255,107,107,0.1)'}; padding: 12px; border-radius: 8px; margin-bottom: 12px;">
      <div style="font-weight: 600; margin-bottom: 8px;">Robustness Results</div>
      <div><span class="badge">Success Rate</span> <b>${fmt(successRate, 1)}%</b> of ${N} scenarios passed all requirements</div>
    </div>`;
    
    if (successRate < 100) {
      output += `<div style="background: rgba(255,107,107,0.1); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
        <div style="font-weight: 600; color: var(--danger); margin-bottom: 8px;">Failure Analysis</div>
        <div><span class="badge">Power Limited</span> ${failures.power} scenarios (${fmt(failures.power/N*100, 1)}%)</div>
        <div><span class="badge">Torque Limited</span> ${failures.torque} scenarios (${fmt(failures.torque/N*100, 1)}%)</div>
        <div><span class="badge">RPM Limited</span> ${failures.rpm} scenarios (${fmt(failures.rpm/N*100, 1)}%)</div>
      </div>`;
    }
    
    // Recommendations
    if (successRate < 85) {
      output += `<div style="background: rgba(77,163,255,0.1); padding: 12px; border-radius: 8px;">
        <div style="font-weight: 600; color: var(--accent); margin-bottom: 8px;">Recommendations for Improved Robustness</div>`;
      
      if (failures.power > N * 0.1) {
        output += `<div>‚Ä¢ Increase motor power by ~${Math.ceil((failures.power/N) * 20)}% for better power margin</div>`;
      }
      if (failures.torque > N * 0.1) {
        output += `<div>‚Ä¢ Increase motor torque by ~${Math.ceil((failures.torque/N) * 15)}% or use larger rear cogs</div>`;
      }
      if (failures.rpm > N * 0.1) {
        output += `<div>‚Ä¢ Increase max RPM or use smaller front chainring / larger top cog</div>`;
      }
      
      output += `</div>`;
    } else {
      output += `<div class="ok">System shows good robustness across realistic variations. Your current specs provide adequate safety margins.</div>`;
    }
    
    $('#robustnessOut').innerHTML = output;
  }

  function getSpeedInputFromDisplay(displayValue) {
    return speedUnit === 'mph' ? parseFloat(displayValue) : parseFloat(displayValue) / 1.609344;
  }

  function setSystemLabels() {
    $('#lbl_sys_topSpeed').textContent = `Target top speed (${unitLabel()})`;
    $('#lbl_sys_climbSpeed').textContent = `Climb speed (${unitLabel()})`;
    $('#lbl_sys_range').textContent = `Range (${speedUnit === 'mph' ? 'mi' : 'km'})`;
    $('#lbl_sys_rangeSpeed').textContent = `Range cruise speed (${unitLabel()})`;
  }

  /* ---------- UI glue, events, presets, share, csv ---------- */
  function highlightSelectedRow(){
    $$('#resultTable tbody tr').forEach(tr=>tr.classList.remove('sel'));
    const tr = $(`#resultTable tbody tr:nth-child(${gearIndex+1})`);
    if(tr) tr.classList.add('sel');
  }
  function updateModeUI(){
    const va = $('#powerMode').value==='va';
    $('#voltage').disabled = !va;
    $('#current').disabled = !va;
    $('#mechW').disabled   =  va ? true : false;
  }
  function loadPresetNames(){
    const sel = $('#loadPreset');
    const store = JSON.parse(localStorage.getItem('mdp_presets')||'{}');
    const cur = sel.value;
    sel.innerHTML = `<option value="">Load preset‚Ä¶</option>` + Object.keys(store).sort().map(n=>`<option value="${n}">${n}</option>`).join('');
    if(cur && store[cur]) sel.value = cur;
  }
  function getConfigObject(){
    const obj={};
    $$('input,select').forEach(el=>{
      if(el.id) obj[el.id] = (el.type==='checkbox') ? el.checked : el.value;
    });
    obj.__speedUnit = speedUnit;
    obj.__fxEnabled = fxEnabled;
    return obj;
  }
  function applyConfigObject(obj){
    Object.entries(obj||{}).forEach(([k,v])=>{
      const el = $('#'+k);
      if(!el) return;
      if(el.type==='checkbox') el.checked = !!v; else el.value = v;
    });
    if(obj && obj.__speedUnit){ speedUnit = (obj.__speedUnit==='kph'?'kph':'mph'); setUnitButtons(); setSpeedLabels(); }
    if(obj && typeof obj.__fxEnabled==='boolean'){ setFX(obj.__fxEnabled); }
    compute();
  }
  function setUnitButtons(){
    $('#u_mph').classList.toggle('active', speedUnit==='mph');
    $('#u_kph').classList.toggle('active', speedUnit==='kph');
    $('#u_mph').setAttribute('aria-selected', speedUnit==='mph');
    $('#u_kph').setAttribute('aria-selected', speedUnit==='kph');
  }
  function setFX(on){
    fxEnabled = !!on;
    $('#fx_on').classList.toggle('active', fxEnabled);
    $('#fx_off').classList.toggle('active', !fxEnabled);
    $('#fx_on').setAttribute('aria-selected', fxEnabled);
    $('#fx_off').setAttribute('aria-selected', !fxEnabled);
    if(!fxEnabled) setPlay(true); // pause animation if FX off
  }
  function setPlay(paused){
    animRunning = !paused;
    $('#fx_play').textContent = paused ? 'Play' : 'Pause';
    if(animRunning) startAnim(); else stopAnim();
  }

  const autoCompute = debounce(()=>compute(), 200);
  $$( 'input,select').forEach(el=>{
    el.addEventListener('input', autoCompute, {passive:true});
    el.addEventListener('change', autoCompute);
  });

  $('#computeBtn').addEventListener('click', compute);
  $('#resetBtn').addEventListener('click', ()=>{ resetDefaults(); compute(); });
  $$('.pill[data-rear]').forEach(btn=> btn.addEventListener('click', ()=>{ $('#rearCogs').value=btn.getAttribute('data-rear'); compute(); }));
  $('#preset_power').addEventListener('click', ()=>{ $('#powerMode').value='va'; $('#voltage').value=52; $('#current').value=30; $('#motorEff').value=0.82; updateModeUI(); compute(); });
  $('#preset_rpm').addEventListener('click', ()=>{ $('#maxCadence').value=150; compute(); });
  $('#designBtn').addEventListener('click', designSystem);
  $('#robustnessBtn').addEventListener('click', runRobustnessAnalysis);
  $('#solveBtn').addEventListener('click', solve);
  $('#uncBtn').addEventListener('click', runUncertainty);
  $('#powerMode').addEventListener('change', ()=>{ updateModeUI(); compute(); });

  // Unit toggle
  $('#u_mph').addEventListener('click', ()=>{
    if(speedUnit==='mph') return;
    $$('#u_mph,u_kph').forEach(b=>b.classList.remove('active'));
    $('#u_mph').classList.add('active');
    speedUnit='mph'; setUnitButtons(); setSpeedLabels(); compute();
  });
  $('#u_kph').addEventListener('click', ()=>{
    if(speedUnit==='kph') return;
    $$('#u_mph,u_kph').forEach(b=>b.classList.remove('active'));
    $('#u_kph').classList.add('active');
    speedUnit='kph'; setUnitButtons(); setSpeedLabels(); compute();
  });

  // FX toggle + Play/Pause
  $('#fx_on').addEventListener('click', ()=> setFX(true));
  $('#fx_off').addEventListener('click', ()=> setFX(false));
  $('#fx_play').addEventListener('click', ()=> setPlay(animRunning));

  // Arrow keys gear shift (ignore when typing)
  document.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowUp'){ gearIndex++; gearIndex=clampGear(gearIndex,rears); compute(); }
    else if(e.key==='ArrowDown'){ gearIndex--; gearIndex=clampGear(gearIndex,rears); compute(); e.preventDefault(); }
  });
  $('#gearUp').addEventListener('click', ()=>{ gearIndex++; compute(); });
  $('#gearDown').addEventListener('click', ()=>{ gearIndex--; compute(); });

  // Visualizer RPM controls
  $('#visRpm').addEventListener('input', ()=>{ $('#visRpmNum').value = $('#visRpm').value; updateGearVisualizer(parseRear($('#rearCogs').value)); });
  $('#visRpmNum').addEventListener('input', ()=>{ let v=parseFloat($('#visRpmNum').value)||0; v=Math.max(0,Math.min(300,v)); $('#visRpm').value=v; updateGearVisualizer(parseRear($('#rearCogs').value)); });

  // Wheel preset convenience
  $('#wheelPreset').addEventListener('change', ()=>{
    const isCustom = $('#wheelPreset').value==='custom';
    $('#circumference').disabled = !isCustom;
  });
  $('#circumference').disabled = $('#wheelPreset').value!=='custom';

  // Click-to-select gear row
  $('#resultTable').addEventListener('click', (e)=>{
    const tr = e.target.closest('tr[data-gi]'); if(!tr) return;
    const i = parseInt(tr.getAttribute('data-gi'),10);
    if(Number.isFinite(i)){ gearIndex=i; compute(); }
  });

  // Presets
  $('#savePreset').addEventListener('click', ()=>{
    const name = $('#presetName').value.trim();
    if(!name){ alert('Preset name cannot be empty.'); return; }
    const store = JSON.parse(localStorage.getItem('mdp_presets')||'{}');
    const config = getConfigObject();
    store[name] = config;
    localStorage.setItem('mdp_presets', JSON.stringify(store));
    loadPresetNames();
    $('#presetName').value='';
    alert('Preset saved.');
  });
  $('#loadPreset').addEventListener('change', ()=>{
    const name = $('#loadPreset').value;
    if(!name){ resetDefaults(); compute(); return; }
    const store = JSON.parse(localStorage.getItem('mdp_presets')||'{}');
    if(store[name]) applyConfigObject(store[name]);
  });
  $('#deletePreset').addEventListener('click', ()=>{
    const name = $('#loadPreset').value || ($('#presetName').value||'').trim();
    if(!name){ alert('Pick a preset to delete.'); return; }
    const store = JSON.parse(localStorage.getItem('mdp_presets')||'{}');
    if(store[name]){ delete store[name]; localStorage.setItem('mdp_presets', JSON.stringify(store)); loadPresetNames(); }
  });
  loadPresetNames();

  // Share URL
  $('#shareBtn').addEventListener('click', ()=>{
    const url = new URL(window.location);
    const params = new URLSearchParams();
    $$('.calc-param').forEach(el=>{
      if(el.id) params.set(el.id, el.value);
    });
    params.set('__speedUnit', speedUnit);
    params.set('__fxEnabled', fxEnabled);
    url.search = params.toString();
    const txt = `Share this URL for your bike setup: ${url.href}`;
    $('#shareMsg').textContent = txt;
    navigator.clipboard.writeText(txt).then(()=>{ alert('Share URL copied to clipboard!'); });
  });

  // Resize re-draw
  window.addEventListener('resize', ()=>{ clearTimeout(window.__rz); window.__rz=setTimeout(()=>{ drawGearCanvas(parseRear($('#rearCogs').value)); compute(); },120); }, {passive:true});
  if('ResizeObserver' in window){
    const ro = new ResizeObserver(entries=>{
      for(const entry of entries){
        const id = entry.target.id;
        if(id==='gearCanvas'){
          drawGearCanvas(parseRear($('#rearCogs').value));
        }
      }
    });
    ['gearCanvas'].forEach(id=>{
      const el = document.getElementById(id); if(el) ro.observe(el);
    });
  }

  /* ---------- Animation loop ---------- */
  function tick(ts){
    if(!animRunning || !fxEnabled) return;
    if(!lastT) lastT = ts;
    const dt = Math.min(0.05, (ts - lastT)/1000);
    lastT = ts;

    const rears = parseRear($('#rearCogs').value);
    if(!rears.length) return;

    const frontT = parseInt($('#frontTeeth').value,10)||40;
    const rearT = rears[gearIndex];
    const visRpm = Math.max(0, parseFloat($('#visRpmNum').value)||1);
    const ratio = frontT/rearT;

    // Calculate angular velocities in radians per second
    const wFront = 2*Math.PI*(visRpm/60);
    const wRear = 2*Math.PI*(visRpm*ratio/60);

    // Update rotation angles
    angFront += wFront * dt;
    angRear += wRear * dt;

    // Update chain animation
    const rFront = Math.max(20, Math.sqrt(frontT)*2.4);
    const chainSpeedPxPerSec = (2*Math.PI*rFront) * (visRpm/60);
    chainOffset += chainSpeedPxPerSec * dt;

    drawGearCanvas(rears);
    animId = requestAnimationFrame(tick);
  }

  function startAnim(){
    if(!fxEnabled) return;
    if(animId) cancelAnimationFrame(animId);
    lastT = 0;
    animId = requestAnimationFrame(tick);
  }
  function stopAnim(){
    if(animId){ cancelAnimationFrame(animId); animId = null; }
  }

  // Add the missing solve and runUncertainty functions:
  function solve(){
    const circ=getCirc(), radius=circ/(2*Math.PI);
    const m=parseFloat($('#mass').value), Crr=0.006, CdA=0.60, rho=1.20;
    const riderW=Math.max(0,parseFloat($('#riderW').value));
    const Tcrank=parseFloat($('#crankTorque').value), eff=parseFloat($('#driveEff').value);
    const V=parseFloat($('#voltage').value), A=parseFloat($('#current').value), motorEff=parseFloat($('#motorEff').value);
    const maxCad=parseFloat($('#maxCadence').value);
    const climbMph=getSpeedInputMph('climbMph'), v=climbMph*MPS_PER_MPH;
    const targetTopMph=getSpeedInputMph('targetTopMph'), targetGrade=(parseFloat($('#targetGradePct').value)||0)/100;
    const fixedWhat=$('#fixedWhat').value;
    const fixedRing=parseInt($('#fixedRing').value,10);
    const fixedSmall=parseInt($('#fixedSmall').value,10);
    const fixedLarge=parseInt($('#fixedLarge').value,10);

    const mode=$('#powerMode').value;
    let P_mech=0;
    if(mode==='va'){ P_mech=V*A*motorEff; } else { P_mech=Math.max(0,parseFloat($('#mechW').value)||0); }
    P_mech += riderW;

    const vFlat = binSearchTopSpeedFlat(P_mech, m, Crr, rho, CdA);
    const topFlatMph = vFlat*MPH_PER_MPS;
    const needTopMps = targetTopMph * MPS_PER_MPH;
    const ratioReq = needTopMps*60/(maxCad*circ);
    const Tw_req = (((targetGrade + Crr)*m*g) + 0.5*rho*CdA*v*v) * radius;

    function pickSmall(front){
      const maxSmall = Math.floor(front/ratioReq);
      const cand = stdSmall.filter(s=>s<=maxSmall);
      return cand.length? Math.max(...cand) : null;
    }
    function pickLarge(front){
      const rearNeeded = Math.ceil(front * Tw_req/(Tcrank*eff));
      const cand = stdLarge.filter(L=>L>=rearNeeded);
      return cand.length? Math.min(...cand) : null;
    }

    let report='';
    if(topFlatMph < targetTopMph){ report += `<div class="no">Flat power-limited top speed is ${fmt(mphToDisplay(topFlatMph),1)} ${unitLabel()}, below target ${fmt(mphToDisplay(targetTopMph),1)} ${unitLabel()}.</div>`; }
    const gPower = ((P_mech/v) - 0.5*rho*CdA*v*v)/(m*g) - Crr;
    if(gPower < targetGrade){ report += `<div class="no">Power-limited grade at ${fmt(mphToDisplay(climbMph),1)} ${unitLabel()} is ${(gPower*100).toFixed(1)}%, below target ${(targetGrade*100).toFixed(1)}%.</div>`; }
    if(!report) report = `<div class="ok">Targets look power-feasible. Now checking gearing‚Ä¶</div>`;

    let suggestion='';
    if(fixedWhat==='none'){
      let best=null;
      stdSmall.forEach(s=>{
        const ring = Math.ceil(ratioReq*s);
        const L = pickLarge(ring);
        if(L){ if(!best || ring<best.ring) best={ring,s,L}; }
      });
      suggestion = best
        ? `Suggested: <b>${best.ring}T</b> ring with cassette <b>${best.s}‚Äì${best.L}T</b>.`
        : `No standard combo (11‚Äì14T top, 26‚Äì50T low) meets both targets; raise rpm/power or relax targets.`;
    } else if(fixedWhat==='ring'){
      const s = pickSmall(fixedRing);
      const L = pickLarge(fixedRing);
      if(s && L) suggestion = `With a fixed <b>${fixedRing}T</b> ring, use cassette about <b>${s}‚Äì${L}T</b>.`;
      else if(!s && L) suggestion = `Top-speed target demands a smaller top cog than standard allows for a ${fixedRing}T ring. Increase ring size or rpm.`;
      else if(s && !L) suggestion = `Climb target needs a larger low cog (‚â•${Math.ceil(fixedRing*Tw_req/(Tcrank*eff))}T). Consider 40‚Äì50T low or a smaller ring.`;
      else suggestion = `Both targets conflict for a ${fixedRing}T ring. Raise rpm/power or adjust targets.`;
    } else {
      const frontMin = Math.ceil(ratioReq*fixedSmall);
      const frontMax = Math.floor( (fixedLarge*Tcrank*eff)/Tw_req );
      if(frontMin <= frontMax){
        suggestion = `With cassette <b>${fixedSmall}‚Äì${fixedLarge}T</b>, pick a ring around <b>${frontMin}T</b> (any in <b>${frontMin}‚Äì${frontMax}T</b> works).`;
      } else {
        suggestion = `With cassette <b>${fixedSmall}‚Äì${fixedLarge}T</b> there's no ring that hits both targets. Increase low cog to ‚â•<b>${Math.ceil(frontMin*Tw_req/(Tcrank*eff))}T</b> or raise rpm/power.`;
      }
    }

    $('#solveOut').innerHTML = report + `<div style="margin-top:6px">${suggestion}</div>`;
  }

  function rand(min,max){ return min + Math.random()*(max-min); }
  function percentile(arr,p){
    if(arr.length===0) return NaN;
    const a=arr.slice().sort((x,y)=>x-y);
    const idx=Math.min(a.length-1, Math.max(0, Math.floor((p/100)*(a.length-1))));
    return a[idx];
  }

  function runUncertainty(){
    const N = Math.max(10, parseInt($('#u_N').value,10)||300);
    const circ=getCirc(), radius=circ/(2*Math.PI);
    const front=parseInt($('#frontTeeth').value,10);
    const climbMph=getSpeedInputMph('climbMph'), v=climbMph*MPS_PER_MPH;
    const targetTopMph=getSpeedInputMph('targetTopMph'), targetGrade=parseFloat($('#targetGradePct').value)/100;
    const fixedWhat=$('#fixedWhat').value;
    const fixedRing=parseInt($('#fixedRing').value,10);
    const fixedSmall=parseInt($('#fixedSmall').value,10);
    const fixedLarge=parseInt($('#fixedLarge').value,10);
    const mode=$('#powerMode').value;
    const chainEff=parseFloat($('#driveEff').value);

    const mMin=parseFloat($('#u_mass_min').value), mMax=parseFloat($('#u_mass_max').value);
    const rpmMin=parseFloat($('#u_rpm_min').value), rpmMax=parseFloat($('#u_rpm_max').value);
    const Vmin=parseFloat($('#u_V_min').value), Vmax=parseFloat($('#u_V_max').value);
    const Amin=parseFloat($('#u_A_min').value), Amax=parseFloat($('#u_A_max').value);
    const effMin=parseFloat($('#u_eff_min').value), effMax=parseFloat($('#u_eff_max').value);
    const TMin=parseFloat($('#u_T_min').value), TMax=parseFloat($('#u_T_max').value);
    const RWmin=parseFloat($('#u_RW_min').value), RWmax=parseFloat($('#u_RW_max').value);
    const mechW_base=parseFloat($('#mechW').value);

    let feasible=0, powerTopFails=0, powerClimbFails=0, gearTopFails=0, gearClimbFails=0;
    const reqRingList=[], reqSmallList=[], reqLargeList=[];

    for(let i=0;i<N;i++){
      // Randomize inputs within specified ranges
      const m = rand(mMin, mMax);
      const Crr = rand(0.005, 0.008);
      const CdA = rand(0.55, 0.70);
      const rho = 1.20;
      const RW = rand(RWmin, RWmax);
      const rpm = rand(rpmMin, rpmMax);
      const V = mode === 'va' ? rand(Vmin, Vmax) : parseFloat($('#voltage').value);
      const A = mode === 'va' ? rand(Amin, Amax) : parseFloat($('#current').value);
      const eff = mode === 'va' ? rand(effMin, effMax) : parseFloat($('#motorEff').value);
      const Tcrank = rand(TMin, TMax);
      const P_mech = (mode === 'va' ? (V * A * eff) : mechW_base) + RW;

      // Calculate top speed and torque for the current scenario
      const vFlat = binSearchTopSpeedFlat(P_mech, m, Crr, rho, CdA);
      const topFlatMph = vFlat * MPH_PER_MPS;
      const needTopMps = targetTopMph * MPS_PER_MPH;
      const ratioReq = needTopMps * 60 / (rpm * circ);
      const Tw_req = (((targetGrade + Crr) * m * g) + 0.5 * rho * CdA * v * v) * radius;

      let powerOK = (topFlatMph >= targetTopMph) && ((((P_mech / v) - 0.5 * rho * CdA * v * v) / (m * g)) - Crr) >= targetGrade;
      if (!powerOK) {
        if (topFlatMph < targetTopMph) powerTopFails++; else powerClimbFails++;
      }

      let gearOK = false, needRing = null, needSmall = null, needLarge = null;
      function needLargeFor(frontTeeth) { return Math.ceil(frontTeeth * Tw_req / (Tcrank * chainEff)); }

      if (fixedWhat === 'none') {
        let best = null;
        stdSmall.forEach(s => {
          const ring = Math.ceil(ratioReq * s);
          const Lneed = needLargeFor(ring);
          const L = stdLarge.find(x => x >= Lneed);
          if (L) { const cand = { ring, s, L }; if (!best || ring < best.ring) best = cand; }
        });
        if (best) { gearOK = true; needRing = best.ring; needSmall = best.s; needLarge = best.L; }
      } else if (fixedWhat === 'ring') {
        const maxSmall = Math.floor(fixedRing / ratioReq);
        const s = stdSmall.filter(x => x <= maxSmall).slice(-1)[0];
        const Lneed = needLargeFor(fixedRing);
        const L = stdLarge.find(x => x >= Lneed);
        if (s && L) { gearOK = true; needRing = fixedRing; needSmall = s; needLarge = L; }
      } else {
        const frontMin = Math.ceil(ratioReq * fixedSmall);
        const frontMax = Math.floor((fixedLarge * Tcrank * eff) / Tw_req);
        if (frontMin <= frontMax) { gearOK = true; needRing = frontMin; needSmall = fixedSmall; needLarge = fixedLarge; }
      }

      if (!gearOK) { if (topFlatMph >= targetTopMph) gearTopFails++; else gearClimbFails++; }

      if (powerOK && gearOK) {
        feasible++;
        reqRingList.push(needRing);
        reqSmallList.push(needSmall);
        reqLargeList.push(needLarge);
      }
    }

    const cov = feasible / N * 100;
    const ringP95 = Math.ceil(percentile(reqRingList, 95));
    const ringP100 = Math.ceil(percentile(reqRingList, 100));
    const smallMax = reqSmallList.length ? Math.max(...reqSmallList) : NaN;
    const largeP95 = percentile(reqLargeList, 95);
    const largeP100 = percentile(reqLargeList, 100);

    let txt = `<div><span class="badge">Coverage</span> ${fmt(cov, 1)}% of ${N} scenarios meet both power & gearing with your constraints.</div>`;
    if (N - feasible > 0) {
      txt += `<div style="margin-top:4px"><span class="badge">Why failures?</span> power(flat top) ${powerTopFails}, power(climb) ${powerClimbFails}, gearing limits ${gearTopFails + gearClimbFails}.</div>`;
    }

    if (reqRingList.length > 0) {
      txt += `<div style="margin-top:6px"><span class="badge">95% design</span> choose ring ‚âà <b>${ringP95}T</b>, top cog ‚â§ <b>${(isNaN(smallMax) ? '‚Äî' : smallMax + 'T')}</b>, low cog ‚â• <b>${largeP95}T</b>.</div>`;
      txt += `<div style="margin-top:4px"><span class="badge">100% design</span> ring ‚âà <b>${ringP100}T</b>, top cog ‚â§ <b>${(isNaN(smallMax) ? '‚Äî' : smallMax + 'T')}</b>, low cog ‚â• <b>${largeP100}T</b>.</div>`;
      txt += `<div class="note" style="margin-top:4px">Pick the nearest real parts: small from [11,12,13,14] and low from [26,28,30,32,34,36,40,42,46,50].</div>`;
    } else {
      txt += `<div class="no" style="margin-top:6px">No scenario satisfied both power and gearing with the current constraints. Consider raising rpm/power or relaxing targets.</div>`;
    }

    $('#uncOut').innerHTML = txt;
  }

  // public controls
  function resetDefaults(){
    $('#wheelPreset').value='2100'; $('#circumference').value='';
    $('#frontTeeth').value=40; $('#rearCogs').value='13,14,16,18,21,24,28,34';
    $('#mass').value=160;
    $('#riderW').value=0; setSpeedInputDisplayFromMph('climbMph',3);
    $('#powerMode').value='va';
    $('#voltage').value=52; $('#current').value=30; $('#motorEff').value=0.82; $('#mechW').value=1280;
    $('#crankTorque').value=160; $('#driveEff').value=0.95; $('#maxCadence').value=140;
    $('#batAh').value=20; $('#usablePct').value=85; setSpeedInputDisplayFromMph('rangeMph',20); $('#rangeGradePct').value=10;
    $('#visRpm').value=1; $('#visRpmNum').value=1;
    setSpeedInputDisplayFromMph('targetTopMph',29);
    gearIndex = 0; firstCompute = true;
    updateModeUI();
  }

  /* ---------- Tooltip system (desktop + mobile) ---------- */
  let tipSeq = 0;
  function mkTipButton(title, body, below=false){
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='help-icon' + (below?' tip-below':'');
    btn.setAttribute('aria-label','Help');
    const id = `tip_${++tipSeq}`;
    btn.setAttribute('aria-expanded','false');
    btn.setAttribute('aria-controls', id);
    btn.innerHTML = '?';
    const bubble = document.createElement('div');
    bubble.className='tip-bubble';
    bubble.id = id;
    bubble.setAttribute('role','tooltip');
    bubble.innerHTML = (title? `<span class="tip-title">${title}</span>`:'') + body;
    btn.appendChild(bubble);
    // interactions
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = btn.classList.toggle('open');
      btn.setAttribute('aria-expanded', open?'true':'false');
      if(open) closeOtherTips(btn);
      clampTipToViewport(bubble);
    });
    btn.addEventListener('keydown', (e)=>{
      if(e.key==='Escape'){ btn.classList.remove('open'); btn.setAttribute('aria-expanded','false'); btn.blur(); }
    });
    return btn;
  }
  function closeOtherTips(except){
    $$('.help-icon.open').forEach(b=>{ if(b!==except){ b.classList.remove('open'); b.setAttribute('aria-expanded','false'); } });
  }
  document.addEventListener('click', ()=> closeOtherTips(null), {passive:true});
  window.addEventListener('scroll', ()=> closeOtherTips(null), {passive:true});

  function clampTipToViewport(bubble){
    const rect = bubble.getBoundingClientRect();
    const pad = 8;
    let dx = 0;
    if(rect.left < pad) dx = pad - rect.left;
    else if(rect.right > window.innerWidth - pad) dx = (window.innerWidth - pad) - rect.right;
    if(dx!==0){
      bubble.style.transform = `translateX(calc(-50% + ${dx}px))`;
    }else{
      bubble.style.transform = '';
    }
  }

  function addTipAfterLabel(forId, title, body, below=false){
    const label = document.querySelector(`label[for="${forId}"]`);
    if(!label) return;
    const tip = mkTipButton(title, body, below);
    label.appendChild(tip); // inline with label text
  }
  function addTipAfterSectionTitle(matchText, title, body, below=true){
    const nodes = $$('.section-title');
    for(const n of nodes){
      if(n.textContent.trim().toLowerCase().includes(matchText.toLowerCase())){
        const tip = mkTipButton(title, body, below);
        n.appendChild(tip);
        break;
      }
    }
  }

  // Add lots of tooltips
  function injectHelp(){
    addTipAfterLabel('wheelPreset','Wheel size preset',
      'Choose a typical wheel. ‚ÄúUse custom circumference‚Äù lets you enter a measured tyre rollout in millimetres (mm). Speed scales linearly with circumference.');
    addTipAfterLabel('circumference','Custom circumference',
      'Roll the bike one wheel revolution and measure ground distance in mm. Leave blank to use the preset value.');
    addTipAfterLabel('frontTeeth','Front chainring teeth',
      'More teeth = higher top speed at the same cadence, but less torque at the wheel for climbing.');
    addTipAfterLabel('rearCogs','Rear cogs (CSV)',
      'Enter sprocket teeth separated by commas (e.g. 13,14,16,‚Ä¶). Values are cleaned, deduplicated and sorted.');

    addTipAfterLabel('mass','Total mass',
      'Rider + bike + cargo, in kilograms (kg). Affects rolling and gravitational loads.');
    addTipAfterLabel('riderW','Rider watts',
      'Average rider mechanical power that adds to the motor at the wheel.');
    addTipAfterLabel('climbMph','Climb speed',
      'The speed used when computing climb grades. Aerodynamic drag grows with v¬≥; slower climbs reduce aero load.');

    addTipAfterLabel('powerMode','Power entry mode',
      'Either compute mechanical power from battery V√óA√óefficiency, or enter shaft mechanical watts directly.');
    addTipAfterLabel('voltage','Battery voltage (V)',
      'Nominal pack voltage. Higher V generally allows more power at the same current.');
    addTipAfterLabel('current','Controller current (A)',
      'Controller battery current limit in amperes (A).');
    addTipAfterLabel('motorEff','Motor+controller efficiency',
      'Fraction (0‚Äì1) converting battery watts to shaft watts. Includes controller+motor losses.');
    addTipAfterLabel('mechW','Mechanical watts',
      'Direct mechanical power at the shaft (use when not in V√óA mode).');
    addTipAfterLabel('crankTorque','Crank torque (Nm)',
      'Available crank torque delivered to the chainring. Affects torque-limited climbs.');
    addTipAfterLabel('driveEff','Drivetrain efficiency',
      'Fraction (0‚Äì1) for chain, sprockets and bearings.');
    addTipAfterLabel('maxCadence','Max chainring rpm',
      'RPM limit at the chainring. Sets the rpm-limited top speed per gear.');

    addTipAfterLabel('batAh','Battery capacity (Ah)',
      'Ampere-hours. Multiply by voltage for watt-hours (Wh). The range calc uses usable Wh.');
    addTipAfterLabel('usablePct','Usable %',
      'Leave some reserve for battery longevity or safety. Range uses this percentage of pack energy.');
    addTipAfterLabel('rangeMph','Range cruise speed',
      'Speed used for range estimation. Includes grade and rider watts.');
    addTipAfterLabel('rangeGradePct','Range grade',
      'Climb grade to include in the range calculation (0% = flat).');

    addTipAfterSectionTitle('Gear visualizer',
      'Visualizer',
      'The animation ties to the chainring rpm slider. Use ‚ñ≤/‚ñº or the buttons to shift. On desktop, Arrow Up/Down also shift.', true);
    addTipAfterLabel('visRpm','Visualizer RPM',
      'Controls animation speed and the live wheel rpm/speed readout.', true);

    addTipAfterSectionTitle('Per-gear results','Per-gear table',
      'Top speed is rpm-limited for each gear; a flat power-limit line shows the aerodynamic+rolling limit independent of gearing.');

    addTipAfterSectionTitle('Reverse engineer','Reverse engineer',
      'Enter targets and constraints. The solver proposes chainring and cassette options that meet both top-speed and climb requirements.');

    addTipAfterSectionTitle('Uncertainty','Uncertainty sweeps',
      'Run a Monte Carlo sweep across ranges (mass, rpm, V/A/eff, torque, drag, rider watts). ‚ÄúCoverage‚Äù reports how many scenarios pass.', true);


    addTipAfterSectionTitle('Gear visualizer',
      'Visualizer',
      'The animation ties to the chainring rpm slider. Use ‚ñ≤/‚ñº or the buttons to shift. On desktop, Arrow Up/Down also shift.', true);
    addTipAfterLabel('visRpm','Visualizer RPM',
      'Controls animation speed and the live wheel rpm/speed readout.', true);

    addTipAfterSectionTitle('Per-gear results','Per-gear table',
      'Top speed is rpm-limited for each gear; a flat power-limit line shows the aerodynamic+rolling limit independent of gearing.');

    addTipAfterSectionTitle('Reverse engineer','Reverse engineer',
      'Enter targets and constraints. The solver proposes chainring and cassette options that meet both top-speed and climb requirements.');

    addTipAfterSectionTitle('Uncertainty','Uncertainty sweeps',
      'Run a Monte Carlo sweep across ranges (mass, rpm, V/A/eff, torque, drag, rider watts). ‚ÄúCoverage‚Äù reports how many scenarios pass.', true);

    // Small help on gear controls
    const gearCtl = document.getElementById('gearControls');
    if(gearCtl){
      const tip = mkTipButton('Shifting',
        '‚ñ≤ shifts to a larger rear cog (easier), ‚ñº to a smaller one (harder). The selected row in the table highlights the current gear.', true);
      gearCtl.appendChild(tip);
    }
  }

  // Init sequence
  setSpeedLabels();
  setUnitButtons();
  setFX(fxEnabled);
  resetDefaults();
  compute();
  
  // Start animation if not disabled by user preference
  if (animRunning) {
    startAnim();
  }

  // Restart animation when rpm or gear changes
  $('#visRpm,#visRpmNum').addEventListener('input', ()=>{ if(animRunning) startAnim(); }, {passive:true});
  $('#gearUp').addEventListener('click', ()=>{ if(animRunning) startAnim(); });
  $('#gearDown').addEventListener('click', ()=>{ if(animRunning) startAnim(); });

  // Inject tooltips once DOM is ready
  injectHelp();
})();
</script>
</body>
</html>